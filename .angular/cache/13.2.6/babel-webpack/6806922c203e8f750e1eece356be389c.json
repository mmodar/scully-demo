{"ast":null,"code":"import { __awaiter } from 'tslib';\nimport * as i3 from '@angular/common';\nimport { DOCUMENT } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Inject, isDevMode, Component, ChangeDetectionStrategy, ViewEncapsulation, NgModule } from '@angular/core';\nimport * as i1 from '@angular/router';\nimport { NavigationStart, GuardsCheckEnd, NavigationEnd } from '@angular/router';\nimport { BehaviorSubject, filter, switchMap, NEVER, of, tap, first, map, shareReplay, pluck, firstValueFrom, takeWhile, catchError, ReplaySubject, merge } from 'rxjs';\nimport * as i2 from '@angular/common/http';\nimport { HttpClientModule } from '@angular/common/http';\nconst _c0 = [\"*\"];\nconst ScullyDefaultSettings = {\n  useTransferState: true,\n  alwaysMonitor: false,\n  manualIdle: false,\n  baseURIForScullyContent: 'http://localhost:1668'\n};\nconst SCULLY_LIB_CONFIG = new InjectionToken('scullyLibConfig', {\n  factory: () => ScullyDefaultSettings\n});\n/**\n * Take a string, preferably resembling an URL, take out the search params, the anchors, and the ending slash\n * @param str\n */\n\nconst basePathOnly = str => {\n  if (str.includes('#')) {\n    str = str.split('#')[0];\n  }\n\n  if (str.includes('?')) {\n    str = str.split('?')[0];\n  }\n\n  const cleanedUpVersion = str.endsWith('/') ? str.slice(0, -1) : str;\n  return cleanedUpVersion;\n}; // tslint:disable: no-string-literal\n\n\nconst isScullyRunning = () => window && window['ScullyIO'] === 'running';\n\nconst isScullyGenerated = () => window && window['ScullyIO'] === 'generated';\n\nfunction mergePaths(base, path) {\n  base = base !== null && base !== void 0 ? base : '';\n\n  if (base.endsWith('/') && path.startsWith('/')) {\n    return `${base}${path.substr(1)}`;\n  }\n\n  if (!base.endsWith('/') && !path.startsWith('/')) {\n    return `${base}/${path}`;\n  }\n\n  return `${base}${path}`;\n}\n\nconst SCULLY_SCRIPT_ID = `ScullyIO-transfer-state`;\nconst SCULLY_STATE_START = `/** ___SCULLY_STATE_START___ */`;\nconst SCULLY_STATE_END = `/** ___SCULLY_STATE_END___ */`;\nconst initialStateDone = '__done__with__Initial__navigation__'; // Adding this dynamic comment to suppress ngc error around Document as a DI token.\n// https://github.com/angular/angular/issues/20351#issuecomment-344009887\n\n/** @dynamic */\n\nlet TransferStateService = /*#__PURE__*/(() => {\n  class TransferStateService {\n    constructor(document, router, http) {\n      this.document = document;\n      this.router = router;\n      this.http = http;\n      /** parse from index, or load from data.json, according to scullConfig setting */\n\n      this.inlineOnly = false;\n      /** set the currentBase to something that it can never be */\n\n      this.currentBaseUrl = '//';\n      /** subject to fire off incoming states */\n\n      this.stateBS = new BehaviorSubject({});\n      this.state$ = this.stateBS.pipe(filter(state => state !== undefined)); // emit the next url when routing is complete\n\n      this.nextUrl = this.router.events.pipe(filter(e => e instanceof NavigationStart), switchMap(e => {\n        if (basePathOnly(this.initialUrl) === basePathOnly(e.url)) {\n          /** don't kick off on initial load to prevent flicker */\n          this.initialUrl = initialStateDone;\n          return NEVER;\n        }\n\n        return of(e);\n      }),\n      /** reset the state, so new components will never get stale data */\n      tap(() => this.stateBS.next(undefined)),\n      /** prevent emitting before navigation to _this_ URL is done. */\n      switchMap(e => this.router.events.pipe(filter(ev => ev instanceof GuardsCheckEnd && ev.url === e.url), first())), map(ev => basePathOnly(ev.urlAfterRedirects || ev.url)), shareReplay(1));\n    }\n\n    startMonitoring() {\n      if (window && window['ScullyIO-injected'] && window['ScullyIO-injected'].inlineStateOnly) {\n        this.inlineOnly = true;\n      }\n\n      this.setupEnvForTransferState();\n      this.setupStartNavMonitoring();\n    }\n\n    setupEnvForTransferState() {\n      if (isScullyRunning()) {\n        this.injectScript(); // In Scully puppeteer\n\n        const exposed = window['ScullyIO-exposed'] || {};\n\n        if (exposed.transferState) {\n          this.stateBS.next(exposed.transferState);\n          this.saveState(exposed.transferState);\n        }\n      } else {\n        // On the client AFTER Scully rendered it. Also store the state in case the user comes from a non-scully page\n        this.initialUrl = window.location.pathname || '__no_NO_no__';\n        this.initialUrl = this.initialUrl !== '/' && this.initialUrl.endsWith('/') ? this.initialUrl.slice(0, -1) : this.initialUrl;\n        /** set the initial state */\n\n        if (isScullyGenerated()) {\n          /** only update the initial state when the page is Scully generated */\n          this.stateBS.next(window && window[SCULLY_SCRIPT_ID] || {});\n        }\n      }\n    }\n\n    injectScript() {\n      this.script = this.document.createElement('script');\n      this.script.setAttribute('id', SCULLY_SCRIPT_ID);\n      let last = this.document.body.lastChild;\n\n      while (last.previousSibling.nodeName === 'SCRIPT') {\n        last = last.previousSibling;\n      } // console.log(`\n      // --------------------------------------------------\n      //    Welp! ${this.script}\n      // --------------------------------------------------\n      // `)\n\n\n      this.document.body.insertBefore(this.script, last);\n    }\n    /**\n     * Getstate will return an observable that containes the data.\n     * It does so right after the navigation for the page has finished.\n     * please note, this works SYNC on initial route, preventing a flash of content.\n     * @param name The name of the state to\n     */\n\n\n    getState(name) {\n      /** start of the fetch for the current active route. */\n      this.fetchTransferState();\n      return this.state$.pipe(pluck(name) // tap((data) => console.log('tss', data))\n      );\n    }\n    /**\n     * Read the current state, and see if it has an value for the name.\n     * (note the value it containes still can be undefined!)\n     */\n\n\n    stateHasKey(name) {\n      return this.stateBS.value && this.stateBS.value.hasOwnProperty(name);\n    }\n    /**\n     * Read the current state, and see if it has an value for the name.\n     * ys also if there is actually an value in the state.\n     */\n\n\n    stateKeyHasValue(name) {\n      return this.stateBS.value && this.stateBS.value.hasOwnProperty(name) && this.stateBS.value[name] != null;\n    }\n    /**\n     * SetState will update the script in the generated page with data added.\n     * @param name\n     * @param val\n     */\n\n\n    setState(name, val) {\n      const newState = Object.assign(Object.assign({}, this.stateBS.value), {\n        [name]: val\n      });\n      this.stateBS.next(newState);\n      this.saveState(newState);\n    }\n\n    saveState(newState) {\n      if (isScullyRunning()) {\n        this.script.textContent = `{window['${SCULLY_SCRIPT_ID}']=_u(String.raw\\`${SCULLY_STATE_START}${escapeHtml(JSON.stringify(newState))}${SCULLY_STATE_END}\\`);function _u(t){t=t.split('${SCULLY_STATE_START}')[1].split('${SCULLY_STATE_END}')[0];const u={'_~b~': \"${'`'}\",'_~q~': \"'\",'_~o~': '$','_~s~': '/','_~l~': '<','_~g~': '>'};return JSON.parse(t.replace(/_~d~/g,'\\\\\\\\\"').replace(/_~[^]~/g, (s) => u[s]).replace(/\\\\n/g,'\\\\\\\\n').replace(/\\\\t/g,'\\\\\\\\t').replace(/\\\\r/g,'\\\\\\\\r'));}}`;\n      }\n    }\n    /**\n     * starts monitoring the router, and keep the url from the last completed navigation handy.\n     */\n\n\n    setupStartNavMonitoring() {\n      if (!isScullyGenerated()) {\n        return;\n      }\n      /** start monitoring the routes */\n\n\n      this.nextUrl.subscribe();\n    }\n    /**\n     * Wraps an observable into scully's transfer state. If data for the provided `name` is\n     * available in the state, it gets returned. Otherwise, the `originalState` observable will\n     * be returned.\n     *\n     * On subsequent calls, the data in the state will always be returned. The `originalState` will\n     * be returned only once.\n     *\n     * This is a convenience method which does not require you to use `getState`/`setState` manually.\n     *\n     * @param name state key\n     * @param originalState an observable which yields the desired data\n     */\n\n\n    useScullyTransferState(name, originalState) {\n      if (isScullyGenerated()) {\n        return this.getState(name);\n      }\n\n      return originalState.pipe(tap(state => this.setState(name, state)));\n    }\n\n    fetchTransferState() {\n      return __awaiter(this, void 0, void 0, function* () {\n        /** helper to read the part before the first slash (ignores leading slash) */\n        const base = url => url.split('/').filter(part => part.trim() !== '')[0];\n        /** put this in the next event cycle so the correct route can be read */\n\n\n        yield new Promise(r => setTimeout(r, 0));\n        /** get the current url */\n\n        const currentUrl = yield firstValueFrom(this.nextUrl);\n        const baseUrl = base(currentUrl);\n\n        if (this.currentBaseUrl === baseUrl) {\n          /** already monitoring, don't tho a thing */\n          return;\n        }\n        /** keep the baseUrl for later reference */\n\n\n        this.currentBaseUrl = baseUrl;\n        this.nextUrl.pipe(\n        /** keep updating till we move to another route */\n        takeWhile(url => base(url) === this.currentBaseUrl), // Get the next route's data from the the index or data file\n        switchMap(url => this.inlineOnly ? this.readFromIndex(url) : this.readFromJson(url)), catchError(e => {\n          // TODO: come up with better error text.\n\n          /** the developer needs to know, but its not fatal, so just return an empty state */\n          console.warn('Error while loading of parsing Scully state:', e);\n          return of({});\n        }), tap(newState => {\n          /** and activate the state in the components. on any error it will be empty */\n          this.stateBS.next(newState);\n        })).subscribe({\n          /** when completes (different URL) */\n          complete: () => {\n            /** reset the currentBaseUrl */\n            this.currentBaseUrl = '//';\n          }\n        });\n      });\n    }\n\n    readFromJson(url) {\n      return firstValueFrom(this.http.get(dropPreSlash(mergePaths(url, '/data.json'))));\n    }\n\n    readFromIndex(url) {\n      return firstValueFrom(this.http.get(dropPreSlash(mergePaths(url, '/index.html')), {\n        responseType: 'text'\n      })).then(html => {\n        const newStateStr = html.split(SCULLY_STATE_START)[1].split(SCULLY_STATE_END)[0];\n        return JSON.parse(unescapeHtml(newStateStr));\n      });\n    }\n\n  }\n\n  /** @nocollapse */\n  TransferStateService.ɵfac = function TransferStateService_Factory(t) {\n    return new (t || TransferStateService)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(i1.Router), i0.ɵɵinject(i2.HttpClient));\n  };\n  /** @nocollapse */\n\n\n  TransferStateService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: TransferStateService,\n    factory: TransferStateService.ɵfac,\n    providedIn: 'root'\n  });\n  return TransferStateService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction dropPreSlash(string) {\n  return string.startsWith('/') ? string.slice(1) : string;\n}\n/**\n * we need to escape our HTML to prevent XXS,\n * It needs to be custom, because the content can already contain html-escaped sequences\n **/\n\n\nfunction escapeHtml(text) {\n  const escapedText = {\n    \"'\": '_~q~',\n    $: '_~o~',\n    '`': '_~b~',\n    '/': '_~s~',\n    '<': '_~l~',\n    '>': '_~g~'\n  };\n  return text\n  /** escape the json */\n  .replace(/[\\$`'<>\\/]/g, s => escapedText[s])\n  /** replace escaped double-quotes with single */\n  .replace(/\\\\\\\"/g, `_~d~`);\n}\n/**\n * Unescape our custom escaped texts\n * @param text\n */\n\n\nfunction unescapeHtml(text) {\n  const unescapedText = {\n    '_~q~': \"'\",\n    '_~b~': '`',\n    '_~o~': '$',\n    '_~s~': '/',\n    '_~l~': '<',\n    '_~g~': '>'\n  };\n  return text\n  /** put back escaped double quotes to make valid json again */\n  .replace(/_~d~/g, `\\\\\"`)\n  /** replace the custom escapes */\n  .replace(/_~[^]~/g, s => unescapedText[s])\n  /** restore newlines+cr */\n  .replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r');\n} // if (window) {\n//   window.addEventListener('AngularReady', ev => {\n//     console.log('appReady fired', ev);\n//   });\n// }\n// Adding this dynamic comment to suppress ngc error around Document as a DI token.\n// https://github.com/angular/angular/issues/20351#issuecomment-344009887\n\n/** @dynamic */\n\n\nlet IdleMonitorService = /*#__PURE__*/(() => {\n  class IdleMonitorService {\n    constructor(zone, router, conf, document, tss) {\n      this.zone = zone;\n      this.router = router;\n      this.document = document;\n      /** store the 'landing' url so we can skip it in idle-check. */\n\n      this.initialUrl = dropEndingSlash(window && window.location && window.location.pathname) || '';\n      this.imState = new BehaviorSubject({\n        idle: false,\n        timeOut: 5 * 1000 // 5 seconds timeout as default\n\n      });\n      this.idle$ = this.imState.pipe(pluck('idle'));\n      this.initApp = new Event('AngularInitialized', {\n        bubbles: true,\n        cancelable: false\n      });\n      this.appReady = new Event('AngularReady', {\n        bubbles: true,\n        cancelable: false\n      });\n      this.appTimeout = new Event('AngularTimeout', {\n        bubbles: true,\n        cancelable: false\n      });\n      /** provide the default for missing conf paramter */\n\n      this.scullyLibConfig = Object.assign({}, ScullyDefaultSettings, conf);\n      const exposed = window['ScullyIO-exposed'] || {};\n      const manualIdle = !!exposed.manualIdle;\n\n      if (!this.scullyLibConfig.manualIdle && window && (this.scullyLibConfig.alwaysMonitor || isScullyRunning())) {\n        this.document.dispatchEvent(this.initApp);\n        this.router.events.pipe(filter(ev => ev instanceof NavigationEnd && ev.urlAfterRedirects !== undefined),\n        /** don't check the page that has this setting. event is only importand on page load */\n        filter(ev => manualIdle ? ev.urlAfterRedirects !== this.initialUrl : true), tap(() => this.zoneIdleCheck())).subscribe();\n      }\n\n      if (this.scullyLibConfig.manualIdle) {\n        /** we still need the init event. */\n        this.document.dispatchEvent(this.initApp);\n      }\n\n      if (this.scullyLibConfig.useTransferState) {\n        /** don't start monitoring if people don't use the transferState */\n        tss.startMonitoring();\n      }\n    }\n\n    fireManualMyAppReadyEvent() {\n      return __awaiter(this, void 0, void 0, function* () {\n        return this.document.dispatchEvent(this.appReady);\n      });\n    }\n\n    init() {\n      return firstValueFrom(this.idle$);\n    }\n\n    zoneIdleCheck() {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (Zone === undefined) {\n          return this.simpleTimeout();\n        }\n\n        const taskTrackingZone = Zone.current.get('TaskTrackingZone');\n\n        if (taskTrackingZone === undefined) {\n          return this.simpleTimeout();\n        }\n\n        if (this.imState.value.idle) {\n          yield this.setState('idle', false);\n        }\n        /** run the actual check for 'idle' outsides zone, otherwise it will never come to an end. */\n\n\n        this.zone.runOutsideAngular(() => {\n          let tCancel;\n          let count = 0;\n          const startTime = Date.now();\n\n          const monitor = () => {\n            clearTimeout(tCancel); // console.table(taskTrackingZone.macroTasks);\n\n            if (Date.now() - startTime > 30 * 1000) {\n              /** bail out after 30 seconds. */\n              this.document.dispatchEvent(this.appTimeout);\n              return;\n            }\n\n            if (taskTrackingZone.macroTasks.length > 0 && taskTrackingZone.macroTasks.find(z => z.source.includes('XMLHttpRequest')) !== undefined || count < 1 // make sure it runs at least once!\n            ) {\n              tCancel = setTimeout(() => {\n                count += 1;\n                monitor();\n              }, 50);\n              return;\n            }\n\n            this.zone.run(() => {\n              /** run this inside the zone, and give the app 250Ms to wrap up, before scraping starts */\n              setTimeout(() => {\n                this.document.dispatchEvent(this.appReady);\n                this.setState('idle', true);\n              }, 250);\n            });\n          };\n\n          monitor();\n        });\n      });\n    }\n\n    simpleTimeout() {\n      return __awaiter(this, void 0, void 0, function* () {\n        /** zone not available, use a timeout instead. */\n        console.warn('Scully is using timeouts, add the needed polyfills instead!');\n        yield new Promise(r => setTimeout(r, this.imState.value.timeOut));\n        this.document.dispatchEvent(this.appReady);\n      });\n    }\n\n    setPupeteerTimeoutValue(milliseconds) {\n      this.imState.next(Object.assign(Object.assign({}, this.imState.value), {\n        timeOut: milliseconds\n      }));\n    }\n\n    setState(key, value) {\n      this.imState.next(Object.assign(Object.assign({}, this.imState.value), {\n        [key]: value\n      }));\n    }\n\n  }\n\n  /** @nocollapse */\n  IdleMonitorService.ɵfac = function IdleMonitorService_Factory(t) {\n    return new (t || IdleMonitorService)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i1.Router), i0.ɵɵinject(SCULLY_LIB_CONFIG), i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(TransferStateService));\n  };\n  /** @nocollapse */\n\n\n  IdleMonitorService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: IdleMonitorService,\n    factory: IdleMonitorService.ɵfac,\n    providedIn: 'root'\n  });\n  return IdleMonitorService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction dropEndingSlash(str) {\n  return str.endsWith('/') ? str.slice(0, -1) : str;\n}\n\nlet ScullyRoutesService = /*#__PURE__*/(() => {\n  class ScullyRoutesService {\n    constructor(router, http) {\n      this.router = router;\n      this.http = http;\n      this.refresh = new ReplaySubject(1);\n      /**\n       * An observable with all routes, published and unpublished alike\n       */\n\n      this.allRoutes$ = this.refresh.pipe(switchMap(() => this.http.get('assets/scully-routes.json')), catchError(() => {\n        console.warn('Scully routes file not found, are you running the Scully generated version of your site?');\n        return of([]);\n      }),\n      /** filter out all non-array results */\n      filter(routes => Array.isArray(routes)), map(this.cleanDups), shareReplay({\n        refCount: false,\n        bufferSize: 1\n      }));\n      /**\n       * An observable with available routes (all published routes)\n       */\n\n      this.available$ = this.allRoutes$.pipe(map(list => list.filter(r => r.hasOwnProperty('published') ? r.published !== false : true)), shareReplay({\n        refCount: false,\n        bufferSize: 1\n      }));\n      /**\n       * an observable with all unpublished routes\n       */\n\n      this.unPublished$ = this.allRoutes$.pipe(map(list => list.filter(r => r.hasOwnProperty('published') ? r.published === false : false)), shareReplay({\n        refCount: false,\n        bufferSize: 1\n      }));\n      /**\n       * An observable with the top-level off all published routes.\n       * (in an urls it would be `http://www.sample.org/__thisPart__/subroutes`)\n       */\n\n      this.topLevel$ = this.available$.pipe(map(routes => routes.filter(r => !r.route.slice(1).includes('/'))), shareReplay({\n        refCount: false,\n        bufferSize: 1\n      }));\n      /** kick off first cycle */\n\n      this.reload();\n    }\n    /**\n     * returns an observable that returns the route information for the\n     * route currently selected. subscribes to route-events to update when needed\n     */\n\n\n    getCurrent() {\n      if (!location) {\n        /** probably not in a browser, no current location available */\n        return of();\n      }\n      /** fire off at start, and when navigation is done. */\n\n\n      return merge(of(new NavigationEnd(0, '', '')), this.router.events).pipe(filter(e => e instanceof NavigationEnd), switchMap(() => this.available$), map(list => {\n        const curLocation = basePathOnly(encodeURI(location.pathname).trim());\n        return list.find(r => curLocation === basePathOnly(r.route.trim()) || r.slugs && Array.isArray(r.slugs) && r.slugs.find(slug => curLocation.endsWith(basePathOnly(slug.trim()))));\n      }));\n    }\n    /**\n     * internal, as routes can have multiple slugs, and so occur multiple times\n     * this util function collapses all slugs back into 1 route.\n     */\n\n\n    cleanDups(routes) {\n      const m = new Map();\n      /** check for duplicates by comparing all, include route in comparison if its the only thing, or the only thing with only the tile  */\n\n      routes.forEach(r => m.set(JSON.stringify(Object.assign(Object.assign({}, r), {\n        route: hasOtherprops(r) ? '' : r.route\n      })), r));\n      return [...m.values()];\n    }\n    /** an utility that will force a reload of the `scully-routes.json` file */\n\n\n    reload() {\n      this.refresh.next();\n    }\n\n  }\n\n  /** @nocollapse */\n  ScullyRoutesService.ɵfac = function ScullyRoutesService_Factory(t) {\n    return new (t || ScullyRoutesService)(i0.ɵɵinject(i1.Router), i0.ɵɵinject(i2.HttpClient));\n  };\n  /** @nocollapse */\n\n\n  ScullyRoutesService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ScullyRoutesService,\n    factory: ScullyRoutesService.ɵfac,\n    providedIn: 'root'\n  });\n  return ScullyRoutesService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction hasOtherprops(obj) {\n  const keys = Object.keys(obj);\n\n  if (keys.length === 1 && keys.includes('route')) {\n    return false;\n  }\n\n  if (keys.length === 2 && keys.includes('route') && keys.includes('title')) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Returns an array of nodes coninting all the html comments in the element.\n * When a searchText is given this is narrowed down to only comments that contian this text\n * @param rootElem Element to search nto\n * @param searchText optional string that needs to be in a HTML comment\n */\n\n\nfunction findComments(rootElem, searchText) {\n  const comments = []; // Fourth argument, which is actually obsolete according to the DOM4 standard, seems required in IE 11\n\n  const iterator = document.createNodeIterator(rootElem, NodeFilter.SHOW_COMMENT, {\n    acceptNode: node => {\n      // Logic to determine whether to accept, reject or skip node\n      // In this case, only accept nodes that have content\n      // that is containing our searchText, by rejecting any other nodes.\n      if (searchText && node.nodeValue && !node.nodeValue.includes(searchText)) {\n        return NodeFilter.FILTER_REJECT;\n      }\n\n      return NodeFilter.FILTER_ACCEPT;\n    }\n  } // , false // IE-11 support requires this parameter.\n  );\n  let curNode; // tslint:disable-next-line: no-conditional-assignment\n\n  while (curNode = iterator.nextNode()) {\n    comments.push(curNode);\n  }\n\n  return comments;\n}\n/** this is needed, because otherwise the CLI borks while building */\n\n\nconst scullyBegin = '<!--scullyContent-begin-->';\nconst scullyEnd = '<!--scullyContent-end-->';\n/** use the module's closure to keep a system-wide check for the last handled URL. */\n\nlet lastHandled; // Adding this dynamic comment to suppress ngc error around Document as a DI token.\n// https://github.com/angular/angular/issues/20351#issuecomment-344009887\n\n/** @dynamic */\n\nlet ScullyContentComponent = /*#__PURE__*/(() => {\n  class ScullyContentComponent {\n    constructor(elmRef, srs, router, location, http, document, conf) {\n      this.elmRef = elmRef;\n      this.srs = srs;\n      this.router = router;\n      this.location = location;\n      this.http = http;\n      this.document = document;\n      this.conf = conf;\n      this.baseUrl = this.conf.useTransferState || ScullyDefaultSettings.useTransferState;\n      this.elm = this.elmRef.nativeElement;\n      /** pull in all  available routes into an eager promise */\n\n      this.routes = firstValueFrom(this.srs.allRoutes$);\n      /** monitor the router, so we can update while navigating in the same 'page' see #311 */\n\n      this.routeUpdates$ = this.router.events.pipe(filter(ev => ev instanceof NavigationEnd),\n      /** don't replace if we are already there */\n      filter(ev => lastHandled && !lastHandled.endsWith(basePathOnly(ev.urlAfterRedirects))), tap(r => this.replaceContent()));\n      this.routeSub = this.routeUpdates$.subscribe();\n      /** do this from constructor, so it runs ASAP */\n    }\n\n    ngOnInit() {\n      if (this.elm) {\n        /** this will only fire in a browser environment */\n        this.handlePage();\n      }\n    }\n    /**\n     * Loads the static content from scully into the view\n     * Will fetch the content from sibling links with xmlHTTPrequest\n     */\n\n\n    handlePage() {\n      return __awaiter(this, void 0, void 0, function* () {\n        const curPage = basePathOnly(location.href);\n\n        if (lastHandled === curPage) {\n          /**\n           * Due to the fix we needed for #311\n           * it might happen that this routine is called\n           * twice for the same page.\n           * this code will make sure the second one is ignored.\n           */\n          return;\n        }\n\n        lastHandled = curPage;\n        const template = this.document.createElement('template');\n        const currentCssId = this.getCSSId(this.elm);\n\n        if (window.scullyContent) {\n          /** upgrade existing static content */\n          const htmlString = window.scullyContent.html;\n\n          if (currentCssId !== window.scullyContent.cssId) {\n            /** replace the angular cssId */\n            template.innerHTML = htmlString.split(window.scullyContent.cssId).join(currentCssId);\n          } else {\n            template.innerHTML = htmlString;\n          }\n        } else {\n          /**\n           *   NOTE\n           * when updateting the texts for the errors, make sure you leave the\n           *  `id=\"___scully-parsing-error___\"`\n           * in there. That way users can detect rendering errors in their CI\n           * on a reliable way.\n           */\n          if (isScullyRunning()) {\n            /**\n             * we don't need to fetch the content, as it is already in the window\n             */\n            return;\n          }\n\n          yield firstValueFrom(this.http.get(curPage + '/index.html', {\n            responseType: 'text'\n          })).catch(e => {\n            if (isDevMode()) {\n              /** in devmode (usually in `ng serve`) check the scully server for the content too */\n              const uri = new URL(location.href);\n              const url = `${this.conf.baseURIForScullyContent}/${basePathOnly(uri.pathname)}/index.html`;\n              return firstValueFrom(this.http.get(url, {\n                responseType: 'text'\n              }));\n            } else {\n              return Promise.reject(e);\n            }\n          }).then(html => {\n            try {\n              const htmlString = html.split(scullyBegin)[1].split(scullyEnd)[0];\n\n              if (htmlString.includes('_ngcontent')) {\n                /** update the angular cssId */\n                const atr = '_ngcontent' + htmlString.split('_ngcontent')[1].split('=')[0];\n                template.innerHTML = htmlString.split(atr).join(currentCssId);\n              } else {\n                template.innerHTML = htmlString;\n              }\n            } catch (e) {\n              template.innerHTML = `<h2 id=\"___scully-parsing-error___\">Sorry, could not parse static page content</h2>\n            <p>This might happen if you are not using the static generated pages.</p>`;\n            }\n          }).catch(e => {\n            template.innerHTML = '<h2 id=\"___scully-parsing-error___\">Sorry, could not load static page content</h2>';\n            console.error('problem during loading static scully content', e);\n          });\n        }\n        /** insert the whole thing just before the `<scully-content>` element */\n\n\n        const parent = this.elm.parentElement || this.document.body;\n        const begin = this.document.createComment('scullyContent-begin');\n        const end = this.document.createComment('scullyContent-end');\n        parent.insertBefore(begin, this.elm);\n        parent.insertBefore(template.content, this.elm);\n        parent.insertBefore(end, this.elm);\n        /** upgrade all hrefs to simulated routelinks (in next microtask) */\n\n        setTimeout(() => this.document.querySelectorAll('[href]').forEach(this.upgradeToRoutelink.bind(this)), 10); // document.querySelectorAll('[href]').forEach(this.upgradeToRoutelink.bind(this));\n      });\n    }\n    /**\n     * upgrade a **href** attributes to links that respect the Angular router\n     * and don't do a full page reload. Only works on links that are found in the\n     * Scully route config file.\n     * @param elm the element containing the **hrefs**\n     */\n\n\n    upgradeToRoutelink(elm) {\n      var _a;\n\n      return __awaiter(this, void 0, void 0, function* () {\n        if (!['A', 'BUTTON'].includes(elm.tagName)) {\n          return;\n        }\n\n        const hash = (_a = elm.dataset) === null || _a === void 0 ? void 0 : _a.hash;\n\n        if (hash) {\n          elm.setAttribute('href', '#' + hash);\n          elm.setAttribute('onclick', '');\n\n          elm.onclick = ev => {\n            ev.preventDefault();\n            const destination = document.getElementById(hash);\n\n            if (destination) {\n              const url = new URL(window.location.href);\n              url.hash = hash;\n              history.replaceState('', '', url.toString());\n              destination.scrollIntoView();\n            }\n          };\n\n          return;\n        }\n\n        const routes = yield this.routes;\n        const href = elm.getAttribute('href');\n        const lnk = basePathOnly(href.toLowerCase());\n        const route = routes.find(r => basePathOnly(r.route.toLowerCase()) === lnk);\n        /** only upgrade routes known by scully. */\n\n        if (lnk && route && !lnk.startsWith('#')) {\n          elm.onclick = ev => __awaiter(this, void 0, void 0, function* () {\n            const splitRoute = route.route.split(`/`);\n            const curSplit = location.pathname.split('/'); // loose last \"part\" of route\n\n            curSplit.pop();\n            ev.preventDefault();\n            const routed = yield this.router.navigate(splitRoute).catch(e => {\n              console.error('routing error', e);\n              return false;\n            });\n\n            if (!routed) {\n              return;\n            }\n            /** check for the same route with different \"data\", and NOT a 1 level higher (length), and is not a fragment of th same page */\n\n\n            if (curSplit.every((part, i) => splitRoute[i] === part) && splitRoute.length !== curSplit.length + 1) {\n              setTimeout(() => this.replaceContent(), 10); // a small delay, so we are sure the angular parts in the page are settled enough\n            }\n          });\n        }\n      });\n    }\n\n    replaceContent() {\n      /**\n       * as Angular doesn't destroy the component if we stay on the same page,\n       * we have to manually delete old content. Also we need to kick of loading\n       * the new content. handlePage() takes care of that.\n       */\n\n      /** delete the content, as it is now out of date! */\n      window.scullyContent = undefined;\n      const parent = this.elm.parentElement;\n      let cur = findComments(parent, 'scullyContent-begin')[0];\n\n      while (cur && cur !== this.elm) {\n        const next = cur.nextSibling;\n        parent.removeChild(cur);\n        cur = next;\n      }\n\n      this.handlePage();\n    }\n\n    getCSSId(elm) {\n      return elm.getAttributeNames().find(a => a.startsWith('_ngcontent')) || '';\n    }\n\n    ngOnDestroy() {\n      this.routeSub.unsubscribe();\n      /** reset the lastused */\n\n      lastHandled = '//';\n    }\n\n  }\n\n  /** @nocollapse */\n  ScullyContentComponent.ɵfac = function ScullyContentComponent_Factory(t) {\n    return new (t || ScullyContentComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(ScullyRoutesService), i0.ɵɵdirectiveInject(i1.Router), i0.ɵɵdirectiveInject(i3.Location), i0.ɵɵdirectiveInject(i2.HttpClient), i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(SCULLY_LIB_CONFIG));\n  };\n  /** @nocollapse */\n\n\n  ScullyContentComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ScullyContentComponent,\n    selectors: [[\"scully-content\"]],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function ScullyContentComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    styles: [\"\\n      :host {\\n        display: none;\\n      }\\n      scully-content {\\n        display: none;\\n      }\\n    \"],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return ScullyContentComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ScullyContentModule = /*#__PURE__*/(() => {\n  class ScullyContentModule {}\n\n  /** @nocollapse */\n  ScullyContentModule.ɵfac = function ScullyContentModule_Factory(t) {\n    return new (t || ScullyContentModule)();\n  };\n  /** @nocollapse */\n\n\n  ScullyContentModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ScullyContentModule\n  });\n  /** @nocollapse */\n\n  ScullyContentModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return ScullyContentModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ScullyLibModule = /*#__PURE__*/(() => {\n  class ScullyLibModule {\n    constructor(idle) {\n      this.idle = idle;\n    }\n    /**\n     * We use a little trick to get a working idle-service.\n     * First, we separate out the component in a separate module to prevent a circulair injection\n     * second we create a constuctor that activates the IdleMonitorService. as that is provided for 'root'\n     * there will be only 1 instance in our app.\n     */\n\n\n    static forRoot(config = ScullyDefaultSettings) {\n      config = Object.assign({}, ScullyDefaultSettings, config);\n      return {\n        ngModule: ScullyLibModule,\n        providers: [{\n          provide: SCULLY_LIB_CONFIG,\n          useValue: config\n        }]\n      };\n    }\n\n  }\n\n  /** @nocollapse */\n  ScullyLibModule.ɵfac = function ScullyLibModule_Factory(t) {\n    return new (t || ScullyLibModule)(i0.ɵɵinject(IdleMonitorService));\n  };\n  /** @nocollapse */\n\n\n  ScullyLibModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ScullyLibModule\n  });\n  /** @nocollapse */\n\n  ScullyLibModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[ScullyContentModule, HttpClientModule], ScullyContentModule]\n  });\n  return ScullyLibModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Public API Surface of ng-lib\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { IdleMonitorService, ScullyContentComponent, ScullyContentModule, ScullyLibModule, ScullyRoutesService, TransferStateService, dropEndingSlash, isScullyGenerated, isScullyRunning }; //# sourceMappingURL=scullyio-ng-lib.js.map","map":null,"metadata":{},"sourceType":"module"}