{"ast":null,"code":"import { __awaiter } from 'tslib';\nimport * as i3 from '@angular/common';\nimport { DOCUMENT } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Inject, isDevMode, Component, ChangeDetectionStrategy, ViewEncapsulation, NgModule } from '@angular/core';\nimport * as i1 from '@angular/router';\nimport { NavigationStart, GuardsCheckEnd, NavigationEnd } from '@angular/router';\nimport { BehaviorSubject, filter, switchMap, NEVER, of, tap, first, map, shareReplay, pluck, firstValueFrom, takeWhile, catchError, ReplaySubject, merge } from 'rxjs';\nimport * as i2 from '@angular/common/http';\nimport { HttpClientModule } from '@angular/common/http';\nconst _c0 = [\"*\"];\nconst ScullyDefaultSettings = {\n  useTransferState: true,\n  alwaysMonitor: false,\n  manualIdle: false,\n  baseURIForScullyContent: 'http://localhost:1668'\n};\nconst SCULLY_LIB_CONFIG = new InjectionToken('scullyLibConfig', {\n  factory: () => ScullyDefaultSettings\n});\n/**\n * Take a string, preferably resembling an URL, take out the search params, the anchors, and the ending slash\n * @param str\n */\n\nconst basePathOnly = str => {\n  if (str.includes('#')) {\n    str = str.split('#')[0];\n  }\n\n  if (str.includes('?')) {\n    str = str.split('?')[0];\n  }\n\n  const cleanedUpVersion = str.endsWith('/') ? str.slice(0, -1) : str;\n  return cleanedUpVersion;\n}; // tslint:disable: no-string-literal\n\n\nconst isScullyRunning = () => window && window['ScullyIO'] === 'running';\n\nconst isScullyGenerated = () => window && window['ScullyIO'] === 'generated';\n\nfunction mergePaths(base, path) {\n  base = base !== null && base !== void 0 ? base : '';\n\n  if (base.endsWith('/') && path.startsWith('/')) {\n    return `${base}${path.substr(1)}`;\n  }\n\n  if (!base.endsWith('/') && !path.startsWith('/')) {\n    return `${base}/${path}`;\n  }\n\n  return `${base}${path}`;\n}\n\nconst SCULLY_SCRIPT_ID = `ScullyIO-transfer-state`;\nconst SCULLY_STATE_START = `/** ___SCULLY_STATE_START___ */`;\nconst SCULLY_STATE_END = `/** ___SCULLY_STATE_END___ */`;\nconst initialStateDone = '__done__with__Initial__navigation__'; // Adding this dynamic comment to suppress ngc error around Document as a DI token.\n// https://github.com/angular/angular/issues/20351#issuecomment-344009887\n\n/** @dynamic */\n\nclass TransferStateService {\n  constructor(document, router, http) {\n    this.document = document;\n    this.router = router;\n    this.http = http;\n    /** parse from index, or load from data.json, according to scullConfig setting */\n\n    this.inlineOnly = false;\n    /** set the currentBase to something that it can never be */\n\n    this.currentBaseUrl = '//';\n    /** subject to fire off incoming states */\n\n    this.stateBS = new BehaviorSubject({});\n    this.state$ = this.stateBS.pipe(filter(state => state !== undefined)); // emit the next url when routing is complete\n\n    this.nextUrl = this.router.events.pipe(filter(e => e instanceof NavigationStart), switchMap(e => {\n      if (basePathOnly(this.initialUrl) === basePathOnly(e.url)) {\n        /** don't kick off on initial load to prevent flicker */\n        this.initialUrl = initialStateDone;\n        return NEVER;\n      }\n\n      return of(e);\n    }),\n    /** reset the state, so new components will never get stale data */\n    tap(() => this.stateBS.next(undefined)),\n    /** prevent emitting before navigation to _this_ URL is done. */\n    switchMap(e => this.router.events.pipe(filter(ev => ev instanceof GuardsCheckEnd && ev.url === e.url), first())), map(ev => basePathOnly(ev.urlAfterRedirects || ev.url)), shareReplay(1));\n  }\n\n  startMonitoring() {\n    if (window && window['ScullyIO-injected'] && window['ScullyIO-injected'].inlineStateOnly) {\n      this.inlineOnly = true;\n    }\n\n    this.setupEnvForTransferState();\n    this.setupStartNavMonitoring();\n  }\n\n  setupEnvForTransferState() {\n    if (isScullyRunning()) {\n      this.injectScript(); // In Scully puppeteer\n\n      const exposed = window['ScullyIO-exposed'] || {};\n\n      if (exposed.transferState) {\n        this.stateBS.next(exposed.transferState);\n        this.saveState(exposed.transferState);\n      }\n    } else {\n      // On the client AFTER Scully rendered it. Also store the state in case the user comes from a non-scully page\n      this.initialUrl = window.location.pathname || '__no_NO_no__';\n      this.initialUrl = this.initialUrl !== '/' && this.initialUrl.endsWith('/') ? this.initialUrl.slice(0, -1) : this.initialUrl;\n      /** set the initial state */\n\n      if (isScullyGenerated()) {\n        /** only update the initial state when the page is Scully generated */\n        this.stateBS.next(window && window[SCULLY_SCRIPT_ID] || {});\n      }\n    }\n  }\n\n  injectScript() {\n    this.script = this.document.createElement('script');\n    this.script.setAttribute('id', SCULLY_SCRIPT_ID);\n    let last = this.document.body.lastChild;\n\n    while (last.previousSibling.nodeName === 'SCRIPT') {\n      last = last.previousSibling;\n    } // console.log(`\n    // --------------------------------------------------\n    //    Welp! ${this.script}\n    // --------------------------------------------------\n    // `)\n\n\n    this.document.body.insertBefore(this.script, last);\n  }\n  /**\n   * Getstate will return an observable that containes the data.\n   * It does so right after the navigation for the page has finished.\n   * please note, this works SYNC on initial route, preventing a flash of content.\n   * @param name The name of the state to\n   */\n\n\n  getState(name) {\n    /** start of the fetch for the current active route. */\n    this.fetchTransferState();\n    return this.state$.pipe(pluck(name) // tap((data) => console.log('tss', data))\n    );\n  }\n  /**\n   * Read the current state, and see if it has an value for the name.\n   * (note the value it containes still can be undefined!)\n   */\n\n\n  stateHasKey(name) {\n    return this.stateBS.value && this.stateBS.value.hasOwnProperty(name);\n  }\n  /**\n   * Read the current state, and see if it has an value for the name.\n   * ys also if there is actually an value in the state.\n   */\n\n\n  stateKeyHasValue(name) {\n    return this.stateBS.value && this.stateBS.value.hasOwnProperty(name) && this.stateBS.value[name] != null;\n  }\n  /**\n   * SetState will update the script in the generated page with data added.\n   * @param name\n   * @param val\n   */\n\n\n  setState(name, val) {\n    const newState = Object.assign(Object.assign({}, this.stateBS.value), {\n      [name]: val\n    });\n    this.stateBS.next(newState);\n    this.saveState(newState);\n  }\n\n  saveState(newState) {\n    if (isScullyRunning()) {\n      this.script.textContent = `{window['${SCULLY_SCRIPT_ID}']=_u(String.raw\\`${SCULLY_STATE_START}${escapeHtml(JSON.stringify(newState))}${SCULLY_STATE_END}\\`);function _u(t){t=t.split('${SCULLY_STATE_START}')[1].split('${SCULLY_STATE_END}')[0];const u={'_~b~': \"${'`'}\",'_~q~': \"'\",'_~o~': '$','_~s~': '/','_~l~': '<','_~g~': '>'};return JSON.parse(t.replace(/_~d~/g,'\\\\\\\\\"').replace(/_~[^]~/g, (s) => u[s]).replace(/\\\\n/g,'\\\\\\\\n').replace(/\\\\t/g,'\\\\\\\\t').replace(/\\\\r/g,'\\\\\\\\r'));}}`;\n    }\n  }\n  /**\n   * starts monitoring the router, and keep the url from the last completed navigation handy.\n   */\n\n\n  setupStartNavMonitoring() {\n    if (!isScullyGenerated()) {\n      return;\n    }\n    /** start monitoring the routes */\n\n\n    this.nextUrl.subscribe();\n  }\n  /**\n   * Wraps an observable into scully's transfer state. If data for the provided `name` is\n   * available in the state, it gets returned. Otherwise, the `originalState` observable will\n   * be returned.\n   *\n   * On subsequent calls, the data in the state will always be returned. The `originalState` will\n   * be returned only once.\n   *\n   * This is a convenience method which does not require you to use `getState`/`setState` manually.\n   *\n   * @param name state key\n   * @param originalState an observable which yields the desired data\n   */\n\n\n  useScullyTransferState(name, originalState) {\n    if (isScullyGenerated()) {\n      return this.getState(name);\n    }\n\n    return originalState.pipe(tap(state => this.setState(name, state)));\n  }\n\n  fetchTransferState() {\n    return __awaiter(this, void 0, void 0, function* () {\n      /** helper to read the part before the first slash (ignores leading slash) */\n      const base = url => url.split('/').filter(part => part.trim() !== '')[0];\n      /** put this in the next event cycle so the correct route can be read */\n\n\n      yield new Promise(r => setTimeout(r, 0));\n      /** get the current url */\n\n      const currentUrl = yield firstValueFrom(this.nextUrl);\n      const baseUrl = base(currentUrl);\n\n      if (this.currentBaseUrl === baseUrl) {\n        /** already monitoring, don't tho a thing */\n        return;\n      }\n      /** keep the baseUrl for later reference */\n\n\n      this.currentBaseUrl = baseUrl;\n      this.nextUrl.pipe(\n      /** keep updating till we move to another route */\n      takeWhile(url => base(url) === this.currentBaseUrl), // Get the next route's data from the the index or data file\n      switchMap(url => this.inlineOnly ? this.readFromIndex(url) : this.readFromJson(url)), catchError(e => {\n        // TODO: come up with better error text.\n\n        /** the developer needs to know, but its not fatal, so just return an empty state */\n        console.warn('Error while loading of parsing Scully state:', e);\n        return of({});\n      }), tap(newState => {\n        /** and activate the state in the components. on any error it will be empty */\n        this.stateBS.next(newState);\n      })).subscribe({\n        /** when completes (different URL) */\n        complete: () => {\n          /** reset the currentBaseUrl */\n          this.currentBaseUrl = '//';\n        }\n      });\n    });\n  }\n\n  readFromJson(url) {\n    return firstValueFrom(this.http.get(dropPreSlash(mergePaths(url, '/data.json'))));\n  }\n\n  readFromIndex(url) {\n    return firstValueFrom(this.http.get(dropPreSlash(mergePaths(url, '/index.html')), {\n      responseType: 'text'\n    })).then(html => {\n      const newStateStr = html.split(SCULLY_STATE_START)[1].split(SCULLY_STATE_END)[0];\n      return JSON.parse(unescapeHtml(newStateStr));\n    });\n  }\n\n}\n/** @nocollapse */\n\n\nTransferStateService.ɵfac = function TransferStateService_Factory(t) {\n  return new (t || TransferStateService)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(i1.Router), i0.ɵɵinject(i2.HttpClient));\n};\n/** @nocollapse */\n\n\nTransferStateService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: TransferStateService,\n  factory: TransferStateService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TransferStateService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: Document,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }, {\n      type: i1.Router\n    }, {\n      type: i2.HttpClient\n    }];\n  }, null);\n})();\n\nfunction dropPreSlash(string) {\n  return string.startsWith('/') ? string.slice(1) : string;\n}\n/**\n * we need to escape our HTML to prevent XXS,\n * It needs to be custom, because the content can already contain html-escaped sequences\n **/\n\n\nfunction escapeHtml(text) {\n  const escapedText = {\n    \"'\": '_~q~',\n    $: '_~o~',\n    '`': '_~b~',\n    '/': '_~s~',\n    '<': '_~l~',\n    '>': '_~g~'\n  };\n  return text\n  /** escape the json */\n  .replace(/[\\$`'<>\\/]/g, s => escapedText[s])\n  /** replace escaped double-quotes with single */\n  .replace(/\\\\\\\"/g, `_~d~`);\n}\n/**\n * Unescape our custom escaped texts\n * @param text\n */\n\n\nfunction unescapeHtml(text) {\n  const unescapedText = {\n    '_~q~': \"'\",\n    '_~b~': '`',\n    '_~o~': '$',\n    '_~s~': '/',\n    '_~l~': '<',\n    '_~g~': '>'\n  };\n  return text\n  /** put back escaped double quotes to make valid json again */\n  .replace(/_~d~/g, `\\\\\"`)\n  /** replace the custom escapes */\n  .replace(/_~[^]~/g, s => unescapedText[s])\n  /** restore newlines+cr */\n  .replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r');\n} // if (window) {\n//   window.addEventListener('AngularReady', ev => {\n//     console.log('appReady fired', ev);\n//   });\n// }\n// Adding this dynamic comment to suppress ngc error around Document as a DI token.\n// https://github.com/angular/angular/issues/20351#issuecomment-344009887\n\n/** @dynamic */\n\n\nclass IdleMonitorService {\n  constructor(zone, router, conf, document, tss) {\n    this.zone = zone;\n    this.router = router;\n    this.document = document;\n    /** store the 'landing' url so we can skip it in idle-check. */\n\n    this.initialUrl = dropEndingSlash(window && window.location && window.location.pathname) || '';\n    this.imState = new BehaviorSubject({\n      idle: false,\n      timeOut: 5 * 1000 // 5 seconds timeout as default\n\n    });\n    this.idle$ = this.imState.pipe(pluck('idle'));\n    this.initApp = new Event('AngularInitialized', {\n      bubbles: true,\n      cancelable: false\n    });\n    this.appReady = new Event('AngularReady', {\n      bubbles: true,\n      cancelable: false\n    });\n    this.appTimeout = new Event('AngularTimeout', {\n      bubbles: true,\n      cancelable: false\n    });\n    /** provide the default for missing conf paramter */\n\n    this.scullyLibConfig = Object.assign({}, ScullyDefaultSettings, conf);\n    const exposed = window['ScullyIO-exposed'] || {};\n    const manualIdle = !!exposed.manualIdle;\n\n    if (!this.scullyLibConfig.manualIdle && window && (this.scullyLibConfig.alwaysMonitor || isScullyRunning())) {\n      this.document.dispatchEvent(this.initApp);\n      this.router.events.pipe(filter(ev => ev instanceof NavigationEnd && ev.urlAfterRedirects !== undefined),\n      /** don't check the page that has this setting. event is only importand on page load */\n      filter(ev => manualIdle ? ev.urlAfterRedirects !== this.initialUrl : true), tap(() => this.zoneIdleCheck())).subscribe();\n    }\n\n    if (this.scullyLibConfig.manualIdle) {\n      /** we still need the init event. */\n      this.document.dispatchEvent(this.initApp);\n    }\n\n    if (this.scullyLibConfig.useTransferState) {\n      /** don't start monitoring if people don't use the transferState */\n      tss.startMonitoring();\n    }\n  }\n\n  fireManualMyAppReadyEvent() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.document.dispatchEvent(this.appReady);\n    });\n  }\n\n  init() {\n    return firstValueFrom(this.idle$);\n  }\n\n  zoneIdleCheck() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (Zone === undefined) {\n        return this.simpleTimeout();\n      }\n\n      const taskTrackingZone = Zone.current.get('TaskTrackingZone');\n\n      if (taskTrackingZone === undefined) {\n        return this.simpleTimeout();\n      }\n\n      if (this.imState.value.idle) {\n        yield this.setState('idle', false);\n      }\n      /** run the actual check for 'idle' outsides zone, otherwise it will never come to an end. */\n\n\n      this.zone.runOutsideAngular(() => {\n        let tCancel;\n        let count = 0;\n        const startTime = Date.now();\n\n        const monitor = () => {\n          clearTimeout(tCancel); // console.table(taskTrackingZone.macroTasks);\n\n          if (Date.now() - startTime > 30 * 1000) {\n            /** bail out after 30 seconds. */\n            this.document.dispatchEvent(this.appTimeout);\n            return;\n          }\n\n          if (taskTrackingZone.macroTasks.length > 0 && taskTrackingZone.macroTasks.find(z => z.source.includes('XMLHttpRequest')) !== undefined || count < 1 // make sure it runs at least once!\n          ) {\n            tCancel = setTimeout(() => {\n              count += 1;\n              monitor();\n            }, 50);\n            return;\n          }\n\n          this.zone.run(() => {\n            /** run this inside the zone, and give the app 250Ms to wrap up, before scraping starts */\n            setTimeout(() => {\n              this.document.dispatchEvent(this.appReady);\n              this.setState('idle', true);\n            }, 250);\n          });\n        };\n\n        monitor();\n      });\n    });\n  }\n\n  simpleTimeout() {\n    return __awaiter(this, void 0, void 0, function* () {\n      /** zone not available, use a timeout instead. */\n      console.warn('Scully is using timeouts, add the needed polyfills instead!');\n      yield new Promise(r => setTimeout(r, this.imState.value.timeOut));\n      this.document.dispatchEvent(this.appReady);\n    });\n  }\n\n  setPupeteerTimeoutValue(milliseconds) {\n    this.imState.next(Object.assign(Object.assign({}, this.imState.value), {\n      timeOut: milliseconds\n    }));\n  }\n\n  setState(key, value) {\n    this.imState.next(Object.assign(Object.assign({}, this.imState.value), {\n      [key]: value\n    }));\n  }\n\n}\n/** @nocollapse */\n\n\nIdleMonitorService.ɵfac = function IdleMonitorService_Factory(t) {\n  return new (t || IdleMonitorService)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i1.Router), i0.ɵɵinject(SCULLY_LIB_CONFIG), i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(TransferStateService));\n};\n/** @nocollapse */\n\n\nIdleMonitorService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: IdleMonitorService,\n  factory: IdleMonitorService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(IdleMonitorService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: i0.NgZone\n    }, {\n      type: i1.Router\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [SCULLY_LIB_CONFIG]\n      }]\n    }, {\n      type: Document,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }, {\n      type: TransferStateService\n    }];\n  }, null);\n})();\n\nfunction dropEndingSlash(str) {\n  return str.endsWith('/') ? str.slice(0, -1) : str;\n}\n\nclass ScullyRoutesService {\n  constructor(router, http) {\n    this.router = router;\n    this.http = http;\n    this.refresh = new ReplaySubject(1);\n    /**\n     * An observable with all routes, published and unpublished alike\n     */\n\n    this.allRoutes$ = this.refresh.pipe(switchMap(() => this.http.get('assets/scully-routes.json')), catchError(() => {\n      console.warn('Scully routes file not found, are you running the Scully generated version of your site?');\n      return of([]);\n    }),\n    /** filter out all non-array results */\n    filter(routes => Array.isArray(routes)), map(this.cleanDups), shareReplay({\n      refCount: false,\n      bufferSize: 1\n    }));\n    /**\n     * An observable with available routes (all published routes)\n     */\n\n    this.available$ = this.allRoutes$.pipe(map(list => list.filter(r => r.hasOwnProperty('published') ? r.published !== false : true)), shareReplay({\n      refCount: false,\n      bufferSize: 1\n    }));\n    /**\n     * an observable with all unpublished routes\n     */\n\n    this.unPublished$ = this.allRoutes$.pipe(map(list => list.filter(r => r.hasOwnProperty('published') ? r.published === false : false)), shareReplay({\n      refCount: false,\n      bufferSize: 1\n    }));\n    /**\n     * An observable with the top-level off all published routes.\n     * (in an urls it would be `http://www.sample.org/__thisPart__/subroutes`)\n     */\n\n    this.topLevel$ = this.available$.pipe(map(routes => routes.filter(r => !r.route.slice(1).includes('/'))), shareReplay({\n      refCount: false,\n      bufferSize: 1\n    }));\n    /** kick off first cycle */\n\n    this.reload();\n  }\n  /**\n   * returns an observable that returns the route information for the\n   * route currently selected. subscribes to route-events to update when needed\n   */\n\n\n  getCurrent() {\n    if (!location) {\n      /** probably not in a browser, no current location available */\n      return of();\n    }\n    /** fire off at start, and when navigation is done. */\n\n\n    return merge(of(new NavigationEnd(0, '', '')), this.router.events).pipe(filter(e => e instanceof NavigationEnd), switchMap(() => this.available$), map(list => {\n      const curLocation = basePathOnly(encodeURI(location.pathname).trim());\n      return list.find(r => curLocation === basePathOnly(r.route.trim()) || r.slugs && Array.isArray(r.slugs) && r.slugs.find(slug => curLocation.endsWith(basePathOnly(slug.trim()))));\n    }));\n  }\n  /**\n   * internal, as routes can have multiple slugs, and so occur multiple times\n   * this util function collapses all slugs back into 1 route.\n   */\n\n\n  cleanDups(routes) {\n    const m = new Map();\n    /** check for duplicates by comparing all, include route in comparison if its the only thing, or the only thing with only the tile  */\n\n    routes.forEach(r => m.set(JSON.stringify(Object.assign(Object.assign({}, r), {\n      route: hasOtherprops(r) ? '' : r.route\n    })), r));\n    return [...m.values()];\n  }\n  /** an utility that will force a reload of the `scully-routes.json` file */\n\n\n  reload() {\n    this.refresh.next();\n  }\n\n}\n/** @nocollapse */\n\n\nScullyRoutesService.ɵfac = function ScullyRoutesService_Factory(t) {\n  return new (t || ScullyRoutesService)(i0.ɵɵinject(i1.Router), i0.ɵɵinject(i2.HttpClient));\n};\n/** @nocollapse */\n\n\nScullyRoutesService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ScullyRoutesService,\n  factory: ScullyRoutesService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ScullyRoutesService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: i1.Router\n    }, {\n      type: i2.HttpClient\n    }];\n  }, null);\n})();\n\nfunction hasOtherprops(obj) {\n  const keys = Object.keys(obj);\n\n  if (keys.length === 1 && keys.includes('route')) {\n    return false;\n  }\n\n  if (keys.length === 2 && keys.includes('route') && keys.includes('title')) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Returns an array of nodes coninting all the html comments in the element.\n * When a searchText is given this is narrowed down to only comments that contian this text\n * @param rootElem Element to search nto\n * @param searchText optional string that needs to be in a HTML comment\n */\n\n\nfunction findComments(rootElem, searchText) {\n  const comments = []; // Fourth argument, which is actually obsolete according to the DOM4 standard, seems required in IE 11\n\n  const iterator = document.createNodeIterator(rootElem, NodeFilter.SHOW_COMMENT, {\n    acceptNode: node => {\n      // Logic to determine whether to accept, reject or skip node\n      // In this case, only accept nodes that have content\n      // that is containing our searchText, by rejecting any other nodes.\n      if (searchText && node.nodeValue && !node.nodeValue.includes(searchText)) {\n        return NodeFilter.FILTER_REJECT;\n      }\n\n      return NodeFilter.FILTER_ACCEPT;\n    }\n  } // , false // IE-11 support requires this parameter.\n  );\n  let curNode; // tslint:disable-next-line: no-conditional-assignment\n\n  while (curNode = iterator.nextNode()) {\n    comments.push(curNode);\n  }\n\n  return comments;\n}\n/** this is needed, because otherwise the CLI borks while building */\n\n\nconst scullyBegin = '<!--scullyContent-begin-->';\nconst scullyEnd = '<!--scullyContent-end-->';\n/** use the module's closure to keep a system-wide check for the last handled URL. */\n\nlet lastHandled; // Adding this dynamic comment to suppress ngc error around Document as a DI token.\n// https://github.com/angular/angular/issues/20351#issuecomment-344009887\n\n/** @dynamic */\n\nclass ScullyContentComponent {\n  constructor(elmRef, srs, router, location, http, document, conf) {\n    this.elmRef = elmRef;\n    this.srs = srs;\n    this.router = router;\n    this.location = location;\n    this.http = http;\n    this.document = document;\n    this.conf = conf;\n    this.baseUrl = this.conf.useTransferState || ScullyDefaultSettings.useTransferState;\n    this.elm = this.elmRef.nativeElement;\n    /** pull in all  available routes into an eager promise */\n\n    this.routes = firstValueFrom(this.srs.allRoutes$);\n    /** monitor the router, so we can update while navigating in the same 'page' see #311 */\n\n    this.routeUpdates$ = this.router.events.pipe(filter(ev => ev instanceof NavigationEnd),\n    /** don't replace if we are already there */\n    filter(ev => lastHandled && !lastHandled.endsWith(basePathOnly(ev.urlAfterRedirects))), tap(r => this.replaceContent()));\n    this.routeSub = this.routeUpdates$.subscribe();\n    /** do this from constructor, so it runs ASAP */\n  }\n\n  ngOnInit() {\n    if (this.elm) {\n      /** this will only fire in a browser environment */\n      this.handlePage();\n    }\n  }\n  /**\n   * Loads the static content from scully into the view\n   * Will fetch the content from sibling links with xmlHTTPrequest\n   */\n\n\n  handlePage() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const curPage = basePathOnly(location.href);\n\n      if (lastHandled === curPage) {\n        /**\n         * Due to the fix we needed for #311\n         * it might happen that this routine is called\n         * twice for the same page.\n         * this code will make sure the second one is ignored.\n         */\n        return;\n      }\n\n      lastHandled = curPage;\n      const template = this.document.createElement('template');\n      const currentCssId = this.getCSSId(this.elm);\n\n      if (window.scullyContent) {\n        /** upgrade existing static content */\n        const htmlString = window.scullyContent.html;\n\n        if (currentCssId !== window.scullyContent.cssId) {\n          /** replace the angular cssId */\n          template.innerHTML = htmlString.split(window.scullyContent.cssId).join(currentCssId);\n        } else {\n          template.innerHTML = htmlString;\n        }\n      } else {\n        /**\n         *   NOTE\n         * when updateting the texts for the errors, make sure you leave the\n         *  `id=\"___scully-parsing-error___\"`\n         * in there. That way users can detect rendering errors in their CI\n         * on a reliable way.\n         */\n        if (isScullyRunning()) {\n          /**\n           * we don't need to fetch the content, as it is already in the window\n           */\n          return;\n        }\n\n        yield firstValueFrom(this.http.get(curPage + '/index.html', {\n          responseType: 'text'\n        })).catch(e => {\n          if (isDevMode()) {\n            /** in devmode (usually in `ng serve`) check the scully server for the content too */\n            const uri = new URL(location.href);\n            const url = `${this.conf.baseURIForScullyContent}/${basePathOnly(uri.pathname)}/index.html`;\n            return firstValueFrom(this.http.get(url, {\n              responseType: 'text'\n            }));\n          } else {\n            return Promise.reject(e);\n          }\n        }).then(html => {\n          try {\n            const htmlString = html.split(scullyBegin)[1].split(scullyEnd)[0];\n\n            if (htmlString.includes('_ngcontent')) {\n              /** update the angular cssId */\n              const atr = '_ngcontent' + htmlString.split('_ngcontent')[1].split('=')[0];\n              template.innerHTML = htmlString.split(atr).join(currentCssId);\n            } else {\n              template.innerHTML = htmlString;\n            }\n          } catch (e) {\n            template.innerHTML = `<h2 id=\"___scully-parsing-error___\">Sorry, could not parse static page content</h2>\n            <p>This might happen if you are not using the static generated pages.</p>`;\n          }\n        }).catch(e => {\n          template.innerHTML = '<h2 id=\"___scully-parsing-error___\">Sorry, could not load static page content</h2>';\n          console.error('problem during loading static scully content', e);\n        });\n      }\n      /** insert the whole thing just before the `<scully-content>` element */\n\n\n      const parent = this.elm.parentElement || this.document.body;\n      const begin = this.document.createComment('scullyContent-begin');\n      const end = this.document.createComment('scullyContent-end');\n      parent.insertBefore(begin, this.elm);\n      parent.insertBefore(template.content, this.elm);\n      parent.insertBefore(end, this.elm);\n      /** upgrade all hrefs to simulated routelinks (in next microtask) */\n\n      setTimeout(() => this.document.querySelectorAll('[href]').forEach(this.upgradeToRoutelink.bind(this)), 10); // document.querySelectorAll('[href]').forEach(this.upgradeToRoutelink.bind(this));\n    });\n  }\n  /**\n   * upgrade a **href** attributes to links that respect the Angular router\n   * and don't do a full page reload. Only works on links that are found in the\n   * Scully route config file.\n   * @param elm the element containing the **hrefs**\n   */\n\n\n  upgradeToRoutelink(elm) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!['A', 'BUTTON'].includes(elm.tagName)) {\n        return;\n      }\n\n      const hash = (_a = elm.dataset) === null || _a === void 0 ? void 0 : _a.hash;\n\n      if (hash) {\n        elm.setAttribute('href', '#' + hash);\n        elm.setAttribute('onclick', '');\n\n        elm.onclick = ev => {\n          ev.preventDefault();\n          const destination = document.getElementById(hash);\n\n          if (destination) {\n            const url = new URL(window.location.href);\n            url.hash = hash;\n            history.replaceState('', '', url.toString());\n            destination.scrollIntoView();\n          }\n        };\n\n        return;\n      }\n\n      const routes = yield this.routes;\n      const href = elm.getAttribute('href');\n      const lnk = basePathOnly(href.toLowerCase());\n      const route = routes.find(r => basePathOnly(r.route.toLowerCase()) === lnk);\n      /** only upgrade routes known by scully. */\n\n      if (lnk && route && !lnk.startsWith('#')) {\n        elm.onclick = ev => __awaiter(this, void 0, void 0, function* () {\n          const splitRoute = route.route.split(`/`);\n          const curSplit = location.pathname.split('/'); // loose last \"part\" of route\n\n          curSplit.pop();\n          ev.preventDefault();\n          const routed = yield this.router.navigate(splitRoute).catch(e => {\n            console.error('routing error', e);\n            return false;\n          });\n\n          if (!routed) {\n            return;\n          }\n          /** check for the same route with different \"data\", and NOT a 1 level higher (length), and is not a fragment of th same page */\n\n\n          if (curSplit.every((part, i) => splitRoute[i] === part) && splitRoute.length !== curSplit.length + 1) {\n            setTimeout(() => this.replaceContent(), 10); // a small delay, so we are sure the angular parts in the page are settled enough\n          }\n        });\n      }\n    });\n  }\n\n  replaceContent() {\n    /**\n     * as Angular doesn't destroy the component if we stay on the same page,\n     * we have to manually delete old content. Also we need to kick of loading\n     * the new content. handlePage() takes care of that.\n     */\n\n    /** delete the content, as it is now out of date! */\n    window.scullyContent = undefined;\n    const parent = this.elm.parentElement;\n    let cur = findComments(parent, 'scullyContent-begin')[0];\n\n    while (cur && cur !== this.elm) {\n      const next = cur.nextSibling;\n      parent.removeChild(cur);\n      cur = next;\n    }\n\n    this.handlePage();\n  }\n\n  getCSSId(elm) {\n    return elm.getAttributeNames().find(a => a.startsWith('_ngcontent')) || '';\n  }\n\n  ngOnDestroy() {\n    this.routeSub.unsubscribe();\n    /** reset the lastused */\n\n    lastHandled = '//';\n  }\n\n}\n/** @nocollapse */\n\n\nScullyContentComponent.ɵfac = function ScullyContentComponent_Factory(t) {\n  return new (t || ScullyContentComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(ScullyRoutesService), i0.ɵɵdirectiveInject(i1.Router), i0.ɵɵdirectiveInject(i3.Location), i0.ɵɵdirectiveInject(i2.HttpClient), i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(SCULLY_LIB_CONFIG));\n};\n/** @nocollapse */\n\n\nScullyContentComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n  type: ScullyContentComponent,\n  selectors: [[\"scully-content\"]],\n  ngContentSelectors: _c0,\n  decls: 1,\n  vars: 0,\n  template: function ScullyContentComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵprojectionDef();\n      i0.ɵɵprojection(0);\n    }\n  },\n  styles: [\"\\n      :host {\\n        display: none;\\n      }\\n      scully-content {\\n        display: none;\\n      }\\n    \"],\n  encapsulation: 2,\n  changeDetection: 0\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ScullyContentComponent, [{\n    type: Component,\n    args: [{\n      // tslint:disable-next-line: component-selector\n      selector: 'scully-content',\n      template: '<ng-content></ng-content>',\n      styles: [`\n      :host {\n        display: none;\n      }\n      scully-content {\n        display: none;\n      }\n    `],\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      encapsulation: ViewEncapsulation.None,\n      preserveWhitespaces: true\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }, {\n      type: ScullyRoutesService\n    }, {\n      type: i1.Router\n    }, {\n      type: i3.Location\n    }, {\n      type: i2.HttpClient\n    }, {\n      type: Document,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [SCULLY_LIB_CONFIG]\n      }]\n    }];\n  }, null);\n})();\n\nclass ScullyContentModule {}\n/** @nocollapse */\n\n\nScullyContentModule.ɵfac = function ScullyContentModule_Factory(t) {\n  return new (t || ScullyContentModule)();\n};\n/** @nocollapse */\n\n\nScullyContentModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: ScullyContentModule\n});\n/** @nocollapse */\n\nScullyContentModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ScullyContentModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [ScullyContentComponent],\n      exports: [ScullyContentComponent]\n    }]\n  }], null, null);\n})();\n\nclass ScullyLibModule {\n  constructor(idle) {\n    this.idle = idle;\n  }\n  /**\n   * We use a little trick to get a working idle-service.\n   * First, we separate out the component in a separate module to prevent a circulair injection\n   * second we create a constuctor that activates the IdleMonitorService. as that is provided for 'root'\n   * there will be only 1 instance in our app.\n   */\n\n\n  static forRoot(config = ScullyDefaultSettings) {\n    config = Object.assign({}, ScullyDefaultSettings, config);\n    return {\n      ngModule: ScullyLibModule,\n      providers: [{\n        provide: SCULLY_LIB_CONFIG,\n        useValue: config\n      }]\n    };\n  }\n\n}\n/** @nocollapse */\n\n\nScullyLibModule.ɵfac = function ScullyLibModule_Factory(t) {\n  return new (t || ScullyLibModule)(i0.ɵɵinject(IdleMonitorService));\n};\n/** @nocollapse */\n\n\nScullyLibModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: ScullyLibModule\n});\n/** @nocollapse */\n\nScullyLibModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [[ScullyContentModule, HttpClientModule], ScullyContentModule]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ScullyLibModule, [{\n    type: NgModule,\n    args: [{\n      imports: [ScullyContentModule, HttpClientModule],\n      exports: [ScullyContentModule]\n    }]\n  }], function () {\n    return [{\n      type: IdleMonitorService\n    }];\n  }, null);\n})();\n/*\n * Public API Surface of ng-lib\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { IdleMonitorService, ScullyContentComponent, ScullyContentModule, ScullyLibModule, ScullyRoutesService, TransferStateService, dropEndingSlash, isScullyGenerated, isScullyRunning };","map":{"version":3,"sources":["D:/repos/ng/scully/boost-angular-app-seo/node_modules/@scullyio/ng-lib/fesm2015/scullyio-ng-lib.js"],"names":["__awaiter","i3","DOCUMENT","i0","InjectionToken","Injectable","Inject","isDevMode","Component","ChangeDetectionStrategy","ViewEncapsulation","NgModule","i1","NavigationStart","GuardsCheckEnd","NavigationEnd","BehaviorSubject","filter","switchMap","NEVER","of","tap","first","map","shareReplay","pluck","firstValueFrom","takeWhile","catchError","ReplaySubject","merge","i2","HttpClientModule","ScullyDefaultSettings","useTransferState","alwaysMonitor","manualIdle","baseURIForScullyContent","SCULLY_LIB_CONFIG","factory","basePathOnly","str","includes","split","cleanedUpVersion","endsWith","slice","isScullyRunning","window","isScullyGenerated","mergePaths","base","path","startsWith","substr","SCULLY_SCRIPT_ID","SCULLY_STATE_START","SCULLY_STATE_END","initialStateDone","TransferStateService","constructor","document","router","http","inlineOnly","currentBaseUrl","stateBS","state$","pipe","state","undefined","nextUrl","events","e","initialUrl","url","next","ev","urlAfterRedirects","startMonitoring","inlineStateOnly","setupEnvForTransferState","setupStartNavMonitoring","injectScript","exposed","transferState","saveState","location","pathname","script","createElement","setAttribute","last","body","lastChild","previousSibling","nodeName","insertBefore","getState","name","fetchTransferState","stateHasKey","value","hasOwnProperty","stateKeyHasValue","setState","val","newState","Object","assign","textContent","escapeHtml","JSON","stringify","subscribe","useScullyTransferState","originalState","part","trim","Promise","r","setTimeout","currentUrl","baseUrl","readFromIndex","readFromJson","console","warn","complete","get","dropPreSlash","responseType","then","html","newStateStr","parse","unescapeHtml","ɵfac","Router","HttpClient","ɵprov","type","args","providedIn","Document","decorators","string","text","escapedText","$","replace","s","unescapedText","IdleMonitorService","zone","conf","tss","dropEndingSlash","imState","idle","timeOut","idle$","initApp","Event","bubbles","cancelable","appReady","appTimeout","scullyLibConfig","dispatchEvent","zoneIdleCheck","fireManualMyAppReadyEvent","init","Zone","simpleTimeout","taskTrackingZone","current","runOutsideAngular","tCancel","count","startTime","Date","now","monitor","clearTimeout","macroTasks","length","find","z","source","run","setPupeteerTimeoutValue","milliseconds","key","NgZone","ScullyRoutesService","refresh","allRoutes$","routes","Array","isArray","cleanDups","refCount","bufferSize","available$","list","published","unPublished$","topLevel$","route","reload","getCurrent","curLocation","encodeURI","slugs","slug","m","Map","forEach","set","hasOtherprops","values","obj","keys","findComments","rootElem","searchText","comments","iterator","createNodeIterator","NodeFilter","SHOW_COMMENT","acceptNode","node","nodeValue","FILTER_REJECT","FILTER_ACCEPT","curNode","nextNode","push","scullyBegin","scullyEnd","lastHandled","ScullyContentComponent","elmRef","srs","elm","nativeElement","routeUpdates$","replaceContent","routeSub","ngOnInit","handlePage","curPage","href","template","currentCssId","getCSSId","scullyContent","htmlString","cssId","innerHTML","join","catch","uri","URL","reject","atr","error","parent","parentElement","begin","createComment","end","content","querySelectorAll","upgradeToRoutelink","bind","_a","tagName","hash","dataset","onclick","preventDefault","destination","getElementById","history","replaceState","toString","scrollIntoView","getAttribute","lnk","toLowerCase","splitRoute","curSplit","pop","routed","navigate","every","i","cur","nextSibling","removeChild","getAttributeNames","a","ngOnDestroy","unsubscribe","ElementRef","Location","ɵcmp","selector","styles","changeDetection","OnPush","encapsulation","None","preserveWhitespaces","ScullyContentModule","ɵmod","ɵinj","declarations","exports","ScullyLibModule","forRoot","config","ngModule","providers","provide","useValue","imports"],"mappings":"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","sourcesContent":["import { __awaiter } from 'tslib';\nimport * as i3 from '@angular/common';\nimport { DOCUMENT } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Inject, isDevMode, Component, ChangeDetectionStrategy, ViewEncapsulation, NgModule } from '@angular/core';\nimport * as i1 from '@angular/router';\nimport { NavigationStart, GuardsCheckEnd, NavigationEnd } from '@angular/router';\nimport { BehaviorSubject, filter, switchMap, NEVER, of, tap, first, map, shareReplay, pluck, firstValueFrom, takeWhile, catchError, ReplaySubject, merge } from 'rxjs';\nimport * as i2 from '@angular/common/http';\nimport { HttpClientModule } from '@angular/common/http';\n\nconst ScullyDefaultSettings = {\n    useTransferState: true,\n    alwaysMonitor: false,\n    manualIdle: false,\n    baseURIForScullyContent: 'http://localhost:1668',\n};\nconst SCULLY_LIB_CONFIG = new InjectionToken('scullyLibConfig', {\n    factory: () => ScullyDefaultSettings,\n});\n\n/**\n * Take a string, preferably resembling an URL, take out the search params, the anchors, and the ending slash\n * @param str\n */\nconst basePathOnly = (str) => {\n    if (str.includes('#')) {\n        str = str.split('#')[0];\n    }\n    if (str.includes('?')) {\n        str = str.split('?')[0];\n    }\n    const cleanedUpVersion = str.endsWith('/') ? str.slice(0, -1) : str;\n    return cleanedUpVersion;\n};\n\n// tslint:disable: no-string-literal\nconst isScullyRunning = () => window && window['ScullyIO'] === 'running';\nconst isScullyGenerated = () => window && window['ScullyIO'] === 'generated';\n\nfunction mergePaths(base, path) {\n    base = base !== null && base !== void 0 ? base : '';\n    if (base.endsWith('/') && path.startsWith('/')) {\n        return `${base}${path.substr(1)}`;\n    }\n    if (!base.endsWith('/') && !path.startsWith('/')) {\n        return `${base}/${path}`;\n    }\n    return `${base}${path}`;\n}\n\nconst SCULLY_SCRIPT_ID = `ScullyIO-transfer-state`;\nconst SCULLY_STATE_START = `/** ___SCULLY_STATE_START___ */`;\nconst SCULLY_STATE_END = `/** ___SCULLY_STATE_END___ */`;\nconst initialStateDone = '__done__with__Initial__navigation__';\n// Adding this dynamic comment to suppress ngc error around Document as a DI token.\n// https://github.com/angular/angular/issues/20351#issuecomment-344009887\n/** @dynamic */\nclass TransferStateService {\n    constructor(document, router, http) {\n        this.document = document;\n        this.router = router;\n        this.http = http;\n        /** parse from index, or load from data.json, according to scullConfig setting */\n        this.inlineOnly = false;\n        /** set the currentBase to something that it can never be */\n        this.currentBaseUrl = '//';\n        /** subject to fire off incoming states */\n        this.stateBS = new BehaviorSubject({});\n        this.state$ = this.stateBS.pipe(filter((state) => state !== undefined));\n        // emit the next url when routing is complete\n        this.nextUrl = this.router.events.pipe(filter((e) => e instanceof NavigationStart), switchMap((e) => {\n            if (basePathOnly(this.initialUrl) === basePathOnly(e.url)) {\n                /** don't kick off on initial load to prevent flicker */\n                this.initialUrl = initialStateDone;\n                return NEVER;\n            }\n            return of(e);\n        }), \n        /** reset the state, so new components will never get stale data */\n        tap(() => this.stateBS.next(undefined)), \n        /** prevent emitting before navigation to _this_ URL is done. */\n        switchMap((e) => this.router.events.pipe(filter((ev) => ev instanceof GuardsCheckEnd && ev.url === e.url), first())), map((ev) => basePathOnly(ev.urlAfterRedirects || ev.url)), shareReplay(1));\n    }\n    startMonitoring() {\n        if (window && window['ScullyIO-injected'] && window['ScullyIO-injected'].inlineStateOnly) {\n            this.inlineOnly = true;\n        }\n        this.setupEnvForTransferState();\n        this.setupStartNavMonitoring();\n    }\n    setupEnvForTransferState() {\n        if (isScullyRunning()) {\n            this.injectScript();\n            // In Scully puppeteer\n            const exposed = window['ScullyIO-exposed'] || {};\n            if (exposed.transferState) {\n                this.stateBS.next(exposed.transferState);\n                this.saveState(exposed.transferState);\n            }\n        }\n        else {\n            // On the client AFTER Scully rendered it. Also store the state in case the user comes from a non-scully page\n            this.initialUrl = window.location.pathname || '__no_NO_no__';\n            this.initialUrl = this.initialUrl !== '/' && this.initialUrl.endsWith('/') ? this.initialUrl.slice(0, -1) : this.initialUrl;\n            /** set the initial state */\n            if (isScullyGenerated()) {\n                /** only update the initial state when the page is Scully generated */\n                this.stateBS.next((window && window[SCULLY_SCRIPT_ID]) || {});\n            }\n        }\n    }\n    injectScript() {\n        this.script = this.document.createElement('script');\n        this.script.setAttribute('id', SCULLY_SCRIPT_ID);\n        let last = this.document.body.lastChild;\n        while (last.previousSibling.nodeName === 'SCRIPT') {\n            last = last.previousSibling;\n        }\n        // console.log(`\n        // --------------------------------------------------\n        //    Welp! ${this.script}\n        // --------------------------------------------------\n        // `)\n        this.document.body.insertBefore(this.script, last);\n    }\n    /**\n     * Getstate will return an observable that containes the data.\n     * It does so right after the navigation for the page has finished.\n     * please note, this works SYNC on initial route, preventing a flash of content.\n     * @param name The name of the state to\n     */\n    getState(name) {\n        /** start of the fetch for the current active route. */\n        this.fetchTransferState();\n        return this.state$.pipe(pluck(name)\n        // tap((data) => console.log('tss', data))\n        );\n    }\n    /**\n     * Read the current state, and see if it has an value for the name.\n     * (note the value it containes still can be undefined!)\n     */\n    stateHasKey(name) {\n        return this.stateBS.value && this.stateBS.value.hasOwnProperty(name);\n    }\n    /**\n     * Read the current state, and see if it has an value for the name.\n     * ys also if there is actually an value in the state.\n     */\n    stateKeyHasValue(name) {\n        return this.stateBS.value && this.stateBS.value.hasOwnProperty(name) && this.stateBS.value[name] != null;\n    }\n    /**\n     * SetState will update the script in the generated page with data added.\n     * @param name\n     * @param val\n     */\n    setState(name, val) {\n        const newState = Object.assign(Object.assign({}, this.stateBS.value), { [name]: val });\n        this.stateBS.next(newState);\n        this.saveState(newState);\n    }\n    saveState(newState) {\n        if (isScullyRunning()) {\n            this.script.textContent = `{window['${SCULLY_SCRIPT_ID}']=_u(String.raw\\`${SCULLY_STATE_START}${escapeHtml(JSON.stringify(newState))}${SCULLY_STATE_END}\\`);function _u(t){t=t.split('${SCULLY_STATE_START}')[1].split('${SCULLY_STATE_END}')[0];const u={'_~b~': \"${'`'}\",'_~q~': \"'\",'_~o~': '$','_~s~': '/','_~l~': '<','_~g~': '>'};return JSON.parse(t.replace(/_~d~/g,'\\\\\\\\\"').replace(/_~[^]~/g, (s) => u[s]).replace(/\\\\n/g,'\\\\\\\\n').replace(/\\\\t/g,'\\\\\\\\t').replace(/\\\\r/g,'\\\\\\\\r'));}}`;\n        }\n    }\n    /**\n     * starts monitoring the router, and keep the url from the last completed navigation handy.\n     */\n    setupStartNavMonitoring() {\n        if (!isScullyGenerated()) {\n            return;\n        }\n        /** start monitoring the routes */\n        this.nextUrl.subscribe();\n    }\n    /**\n     * Wraps an observable into scully's transfer state. If data for the provided `name` is\n     * available in the state, it gets returned. Otherwise, the `originalState` observable will\n     * be returned.\n     *\n     * On subsequent calls, the data in the state will always be returned. The `originalState` will\n     * be returned only once.\n     *\n     * This is a convenience method which does not require you to use `getState`/`setState` manually.\n     *\n     * @param name state key\n     * @param originalState an observable which yields the desired data\n     */\n    useScullyTransferState(name, originalState) {\n        if (isScullyGenerated()) {\n            return this.getState(name);\n        }\n        return originalState.pipe(tap((state) => this.setState(name, state)));\n    }\n    fetchTransferState() {\n        return __awaiter(this, void 0, void 0, function* () {\n            /** helper to read the part before the first slash (ignores leading slash) */\n            const base = (url) => url.split('/').filter((part) => part.trim() !== '')[0];\n            /** put this in the next event cycle so the correct route can be read */\n            yield new Promise((r) => setTimeout(r, 0));\n            /** get the current url */\n            const currentUrl = yield firstValueFrom(this.nextUrl);\n            const baseUrl = base(currentUrl);\n            if (this.currentBaseUrl === baseUrl) {\n                /** already monitoring, don't tho a thing */\n                return;\n            }\n            /** keep the baseUrl for later reference */\n            this.currentBaseUrl = baseUrl;\n            this.nextUrl\n                .pipe(\n            /** keep updating till we move to another route */\n            takeWhile((url) => base(url) === this.currentBaseUrl), \n            // Get the next route's data from the the index or data file\n            switchMap((url) => (this.inlineOnly ? this.readFromIndex(url) : this.readFromJson(url))), catchError((e) => {\n                // TODO: come up with better error text.\n                /** the developer needs to know, but its not fatal, so just return an empty state */\n                console.warn('Error while loading of parsing Scully state:', e);\n                return of({});\n            }), tap((newState) => {\n                /** and activate the state in the components. on any error it will be empty */\n                this.stateBS.next(newState);\n            }))\n                .subscribe({\n                /** when completes (different URL) */\n                complete: () => {\n                    /** reset the currentBaseUrl */\n                    this.currentBaseUrl = '//';\n                },\n            });\n        });\n    }\n    readFromJson(url) {\n        return firstValueFrom(this.http.get(dropPreSlash(mergePaths(url, '/data.json'))));\n    }\n    readFromIndex(url) {\n        return firstValueFrom(this.http.get(dropPreSlash(mergePaths(url, '/index.html')), { responseType: 'text' })).then((html) => {\n            const newStateStr = html.split(SCULLY_STATE_START)[1].split(SCULLY_STATE_END)[0];\n            return JSON.parse(unescapeHtml(newStateStr));\n        });\n    }\n}\n/** @nocollapse */ TransferStateService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.6\", ngImport: i0, type: TransferStateService, deps: [{ token: DOCUMENT }, { token: i1.Router }, { token: i2.HttpClient }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ TransferStateService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.6\", ngImport: i0, type: TransferStateService, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.6\", ngImport: i0, type: TransferStateService, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root',\n                }]\n        }], ctorParameters: function () { return [{ type: Document, decorators: [{\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }, { type: i1.Router }, { type: i2.HttpClient }]; } });\nfunction dropPreSlash(string) {\n    return string.startsWith('/') ? string.slice(1) : string;\n}\n/**\n * we need to escape our HTML to prevent XXS,\n * It needs to be custom, because the content can already contain html-escaped sequences\n **/\nfunction escapeHtml(text) {\n    const escapedText = {\n        \"'\": '_~q~',\n        $: '_~o~',\n        '`': '_~b~',\n        '/': '_~s~',\n        '<': '_~l~',\n        '>': '_~g~',\n    };\n    return (text\n        /** escape the json */\n        .replace(/[\\$`'<>\\/]/g, (s) => escapedText[s])\n        /** replace escaped double-quotes with single */\n        .replace(/\\\\\\\"/g, `_~d~`));\n}\n/**\n * Unescape our custom escaped texts\n * @param text\n */\nfunction unescapeHtml(text) {\n    const unescapedText = {\n        '_~q~': \"'\",\n        '_~b~': '`',\n        '_~o~': '$',\n        '_~s~': '/',\n        '_~l~': '<',\n        '_~g~': '>',\n    };\n    return (text\n        /** put back escaped double quotes to make valid json again */\n        .replace(/_~d~/g, `\\\\\"`)\n        /** replace the custom escapes */\n        .replace(/_~[^]~/g, (s) => unescapedText[s])\n        /** restore newlines+cr */\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r'));\n}\n\n// if (window) {\n//   window.addEventListener('AngularReady', ev => {\n//     console.log('appReady fired', ev);\n//   });\n// }\n// Adding this dynamic comment to suppress ngc error around Document as a DI token.\n// https://github.com/angular/angular/issues/20351#issuecomment-344009887\n/** @dynamic */\nclass IdleMonitorService {\n    constructor(zone, router, conf, document, tss) {\n        this.zone = zone;\n        this.router = router;\n        this.document = document;\n        /** store the 'landing' url so we can skip it in idle-check. */\n        this.initialUrl = dropEndingSlash(window && window.location && window.location.pathname) || '';\n        this.imState = new BehaviorSubject({\n            idle: false,\n            timeOut: 5 * 1000, // 5 seconds timeout as default\n        });\n        this.idle$ = this.imState.pipe(pluck('idle'));\n        this.initApp = new Event('AngularInitialized', {\n            bubbles: true,\n            cancelable: false,\n        });\n        this.appReady = new Event('AngularReady', {\n            bubbles: true,\n            cancelable: false,\n        });\n        this.appTimeout = new Event('AngularTimeout', {\n            bubbles: true,\n            cancelable: false,\n        });\n        /** provide the default for missing conf paramter */\n        this.scullyLibConfig = Object.assign({}, ScullyDefaultSettings, conf);\n        const exposed = window['ScullyIO-exposed'] || {};\n        const manualIdle = !!exposed.manualIdle;\n        if (!this.scullyLibConfig.manualIdle && window && (this.scullyLibConfig.alwaysMonitor || isScullyRunning())) {\n            this.document.dispatchEvent(this.initApp);\n            this.router.events\n                .pipe(filter((ev) => ev instanceof NavigationEnd && ev.urlAfterRedirects !== undefined), \n            /** don't check the page that has this setting. event is only importand on page load */\n            filter((ev) => (manualIdle ? ev.urlAfterRedirects !== this.initialUrl : true)), tap(() => this.zoneIdleCheck()))\n                .subscribe();\n        }\n        if (this.scullyLibConfig.manualIdle) {\n            /** we still need the init event. */\n            this.document.dispatchEvent(this.initApp);\n        }\n        if (this.scullyLibConfig.useTransferState) {\n            /** don't start monitoring if people don't use the transferState */\n            tss.startMonitoring();\n        }\n    }\n    fireManualMyAppReadyEvent() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.document.dispatchEvent(this.appReady);\n        });\n    }\n    init() {\n        return firstValueFrom(this.idle$);\n    }\n    zoneIdleCheck() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (Zone === undefined) {\n                return this.simpleTimeout();\n            }\n            const taskTrackingZone = Zone.current.get('TaskTrackingZone');\n            if (taskTrackingZone === undefined) {\n                return this.simpleTimeout();\n            }\n            if (this.imState.value.idle) {\n                yield this.setState('idle', false);\n            }\n            /** run the actual check for 'idle' outsides zone, otherwise it will never come to an end. */\n            this.zone.runOutsideAngular(() => {\n                let tCancel;\n                let count = 0;\n                const startTime = Date.now();\n                const monitor = () => {\n                    clearTimeout(tCancel);\n                    // console.table(taskTrackingZone.macroTasks);\n                    if (Date.now() - startTime > 30 * 1000) {\n                        /** bail out after 30 seconds. */\n                        this.document.dispatchEvent(this.appTimeout);\n                        return;\n                    }\n                    if ((taskTrackingZone.macroTasks.length > 0 &&\n                        taskTrackingZone.macroTasks.find((z) => z.source.includes('XMLHttpRequest')) !==\n                            undefined) ||\n                        count < 1 // make sure it runs at least once!\n                    ) {\n                        tCancel = setTimeout(() => {\n                            count += 1;\n                            monitor();\n                        }, 50);\n                        return;\n                    }\n                    this.zone.run(() => {\n                        /** run this inside the zone, and give the app 250Ms to wrap up, before scraping starts */\n                        setTimeout(() => {\n                            this.document.dispatchEvent(this.appReady);\n                            this.setState('idle', true);\n                        }, 250);\n                    });\n                };\n                monitor();\n            });\n        });\n    }\n    simpleTimeout() {\n        return __awaiter(this, void 0, void 0, function* () {\n            /** zone not available, use a timeout instead. */\n            console.warn('Scully is using timeouts, add the needed polyfills instead!');\n            yield new Promise((r) => setTimeout(r, this.imState.value.timeOut));\n            this.document.dispatchEvent(this.appReady);\n        });\n    }\n    setPupeteerTimeoutValue(milliseconds) {\n        this.imState.next(Object.assign(Object.assign({}, this.imState.value), { timeOut: milliseconds }));\n    }\n    setState(key, value) {\n        this.imState.next(Object.assign(Object.assign({}, this.imState.value), { [key]: value }));\n    }\n}\n/** @nocollapse */ IdleMonitorService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.6\", ngImport: i0, type: IdleMonitorService, deps: [{ token: i0.NgZone }, { token: i1.Router }, { token: SCULLY_LIB_CONFIG }, { token: DOCUMENT }, { token: TransferStateService }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ IdleMonitorService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.6\", ngImport: i0, type: IdleMonitorService, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.6\", ngImport: i0, type: IdleMonitorService, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root',\n                }]\n        }], ctorParameters: function () { return [{ type: i0.NgZone }, { type: i1.Router }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [SCULLY_LIB_CONFIG]\n                }] }, { type: Document, decorators: [{\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }, { type: TransferStateService }]; } });\nfunction dropEndingSlash(str) {\n    return str.endsWith('/') ? str.slice(0, -1) : str;\n}\n\nclass ScullyRoutesService {\n    constructor(router, http) {\n        this.router = router;\n        this.http = http;\n        this.refresh = new ReplaySubject(1);\n        /**\n         * An observable with all routes, published and unpublished alike\n         */\n        this.allRoutes$ = this.refresh.pipe(switchMap(() => this.http.get('assets/scully-routes.json')), catchError(() => {\n            console.warn('Scully routes file not found, are you running the Scully generated version of your site?');\n            return of([]);\n        }), \n        /** filter out all non-array results */\n        filter((routes) => Array.isArray(routes)), map(this.cleanDups), shareReplay({ refCount: false, bufferSize: 1 }));\n        /**\n         * An observable with available routes (all published routes)\n         */\n        this.available$ = this.allRoutes$.pipe(map((list) => list.filter((r) => r.hasOwnProperty('published') ? r.published !== false : true)), shareReplay({ refCount: false, bufferSize: 1 }));\n        /**\n         * an observable with all unpublished routes\n         */\n        this.unPublished$ = this.allRoutes$.pipe(map((list) => list.filter((r) => r.hasOwnProperty('published') ? r.published === false : false)), shareReplay({ refCount: false, bufferSize: 1 }));\n        /**\n         * An observable with the top-level off all published routes.\n         * (in an urls it would be `http://www.sample.org/__thisPart__/subroutes`)\n         */\n        this.topLevel$ = this.available$.pipe(map((routes) => routes.filter((r) => !r.route.slice(1).includes('/'))), shareReplay({ refCount: false, bufferSize: 1 }));\n        /** kick off first cycle */\n        this.reload();\n    }\n    /**\n     * returns an observable that returns the route information for the\n     * route currently selected. subscribes to route-events to update when needed\n     */\n    getCurrent() {\n        if (!location) {\n            /** probably not in a browser, no current location available */\n            return of();\n        }\n        /** fire off at start, and when navigation is done. */\n        return merge(of(new NavigationEnd(0, '', '')), this.router.events).pipe(filter((e) => e instanceof NavigationEnd), switchMap(() => this.available$), map((list) => {\n            const curLocation = basePathOnly(encodeURI(location.pathname).trim());\n            return list.find((r) => curLocation === basePathOnly(r.route.trim()) ||\n                (r.slugs &&\n                    Array.isArray(r.slugs) &&\n                    r.slugs.find((slug) => curLocation.endsWith(basePathOnly(slug.trim())))));\n        }));\n    }\n    /**\n     * internal, as routes can have multiple slugs, and so occur multiple times\n     * this util function collapses all slugs back into 1 route.\n     */\n    cleanDups(routes) {\n        const m = new Map();\n        /** check for duplicates by comparing all, include route in comparison if its the only thing, or the only thing with only the tile  */\n        routes.forEach((r) => m.set(JSON.stringify(Object.assign(Object.assign({}, r), { route: hasOtherprops(r) ? '' : r.route })), r));\n        return [...m.values()];\n    }\n    /** an utility that will force a reload of the `scully-routes.json` file */\n    reload() {\n        this.refresh.next();\n    }\n}\n/** @nocollapse */ ScullyRoutesService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.6\", ngImport: i0, type: ScullyRoutesService, deps: [{ token: i1.Router }, { token: i2.HttpClient }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ ScullyRoutesService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.6\", ngImport: i0, type: ScullyRoutesService, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.6\", ngImport: i0, type: ScullyRoutesService, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root',\n                }]\n        }], ctorParameters: function () { return [{ type: i1.Router }, { type: i2.HttpClient }]; } });\nfunction hasOtherprops(obj) {\n    const keys = Object.keys(obj);\n    if (keys.length === 1 && keys.includes('route')) {\n        return false;\n    }\n    if (keys.length === 2 && keys.includes('route') && keys.includes('title')) {\n        return false;\n    }\n    return true;\n}\n\n/**\n * Returns an array of nodes coninting all the html comments in the element.\n * When a searchText is given this is narrowed down to only comments that contian this text\n * @param rootElem Element to search nto\n * @param searchText optional string that needs to be in a HTML comment\n */\nfunction findComments(rootElem, searchText) {\n    const comments = [];\n    // Fourth argument, which is actually obsolete according to the DOM4 standard, seems required in IE 11\n    const iterator = document.createNodeIterator(rootElem, NodeFilter.SHOW_COMMENT, {\n        acceptNode: node => {\n            // Logic to determine whether to accept, reject or skip node\n            // In this case, only accept nodes that have content\n            // that is containing our searchText, by rejecting any other nodes.\n            if (searchText &&\n                node.nodeValue &&\n                !node.nodeValue.includes(searchText)) {\n                return NodeFilter.FILTER_REJECT;\n            }\n            return NodeFilter.FILTER_ACCEPT;\n        }\n    }\n    // , false // IE-11 support requires this parameter.\n    );\n    let curNode;\n    // tslint:disable-next-line: no-conditional-assignment\n    while ((curNode = iterator.nextNode())) {\n        comments.push(curNode);\n    }\n    return comments;\n}\n\n/** this is needed, because otherwise the CLI borks while building */\nconst scullyBegin = '<!--scullyContent-begin-->';\nconst scullyEnd = '<!--scullyContent-end-->';\n/** use the module's closure to keep a system-wide check for the last handled URL. */\nlet lastHandled;\n// Adding this dynamic comment to suppress ngc error around Document as a DI token.\n// https://github.com/angular/angular/issues/20351#issuecomment-344009887\n/** @dynamic */\nclass ScullyContentComponent {\n    constructor(elmRef, srs, router, location, http, document, conf) {\n        this.elmRef = elmRef;\n        this.srs = srs;\n        this.router = router;\n        this.location = location;\n        this.http = http;\n        this.document = document;\n        this.conf = conf;\n        this.baseUrl = this.conf.useTransferState || ScullyDefaultSettings.useTransferState;\n        this.elm = this.elmRef.nativeElement;\n        /** pull in all  available routes into an eager promise */\n        this.routes = firstValueFrom(this.srs.allRoutes$);\n        /** monitor the router, so we can update while navigating in the same 'page' see #311 */\n        this.routeUpdates$ = this.router.events.pipe(filter((ev) => ev instanceof NavigationEnd), \n        /** don't replace if we are already there */\n        filter((ev) => lastHandled && !lastHandled.endsWith(basePathOnly(ev.urlAfterRedirects))), tap((r) => this.replaceContent()));\n        this.routeSub = this.routeUpdates$.subscribe();\n        /** do this from constructor, so it runs ASAP */\n    }\n    ngOnInit() {\n        if (this.elm) {\n            /** this will only fire in a browser environment */\n            this.handlePage();\n        }\n    }\n    /**\n     * Loads the static content from scully into the view\n     * Will fetch the content from sibling links with xmlHTTPrequest\n     */\n    handlePage() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const curPage = basePathOnly(location.href);\n            if (lastHandled === curPage) {\n                /**\n                 * Due to the fix we needed for #311\n                 * it might happen that this routine is called\n                 * twice for the same page.\n                 * this code will make sure the second one is ignored.\n                 */\n                return;\n            }\n            lastHandled = curPage;\n            const template = this.document.createElement('template');\n            const currentCssId = this.getCSSId(this.elm);\n            if (window.scullyContent) {\n                /** upgrade existing static content */\n                const htmlString = window.scullyContent.html;\n                if (currentCssId !== window.scullyContent.cssId) {\n                    /** replace the angular cssId */\n                    template.innerHTML = htmlString.split(window.scullyContent.cssId).join(currentCssId);\n                }\n                else {\n                    template.innerHTML = htmlString;\n                }\n            }\n            else {\n                /**\n                 *   NOTE\n                 * when updateting the texts for the errors, make sure you leave the\n                 *  `id=\"___scully-parsing-error___\"`\n                 * in there. That way users can detect rendering errors in their CI\n                 * on a reliable way.\n                 */\n                if (isScullyRunning()) {\n                    /**\n                     * we don't need to fetch the content, as it is already in the window\n                     */\n                    return;\n                }\n                yield firstValueFrom(this.http.get(curPage + '/index.html', { responseType: 'text' }))\n                    .catch((e) => {\n                    if (isDevMode()) {\n                        /** in devmode (usually in `ng serve`) check the scully server for the content too */\n                        const uri = new URL(location.href);\n                        const url = `${this.conf.baseURIForScullyContent}/${basePathOnly(uri.pathname)}/index.html`;\n                        return firstValueFrom(this.http.get(url, { responseType: 'text' }));\n                    }\n                    else {\n                        return Promise.reject(e);\n                    }\n                })\n                    .then((html) => {\n                    try {\n                        const htmlString = html.split(scullyBegin)[1].split(scullyEnd)[0];\n                        if (htmlString.includes('_ngcontent')) {\n                            /** update the angular cssId */\n                            const atr = '_ngcontent' + htmlString.split('_ngcontent')[1].split('=')[0];\n                            template.innerHTML = htmlString.split(atr).join(currentCssId);\n                        }\n                        else {\n                            template.innerHTML = htmlString;\n                        }\n                    }\n                    catch (e) {\n                        template.innerHTML = `<h2 id=\"___scully-parsing-error___\">Sorry, could not parse static page content</h2>\n            <p>This might happen if you are not using the static generated pages.</p>`;\n                    }\n                })\n                    .catch((e) => {\n                    template.innerHTML = '<h2 id=\"___scully-parsing-error___\">Sorry, could not load static page content</h2>';\n                    console.error('problem during loading static scully content', e);\n                });\n            }\n            /** insert the whole thing just before the `<scully-content>` element */\n            const parent = this.elm.parentElement || this.document.body;\n            const begin = this.document.createComment('scullyContent-begin');\n            const end = this.document.createComment('scullyContent-end');\n            parent.insertBefore(begin, this.elm);\n            parent.insertBefore(template.content, this.elm);\n            parent.insertBefore(end, this.elm);\n            /** upgrade all hrefs to simulated routelinks (in next microtask) */\n            setTimeout(() => this.document.querySelectorAll('[href]').forEach(this.upgradeToRoutelink.bind(this)), 10);\n            // document.querySelectorAll('[href]').forEach(this.upgradeToRoutelink.bind(this));\n        });\n    }\n    /**\n     * upgrade a **href** attributes to links that respect the Angular router\n     * and don't do a full page reload. Only works on links that are found in the\n     * Scully route config file.\n     * @param elm the element containing the **hrefs**\n     */\n    upgradeToRoutelink(elm) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!['A', 'BUTTON'].includes(elm.tagName)) {\n                return;\n            }\n            const hash = (_a = elm.dataset) === null || _a === void 0 ? void 0 : _a.hash;\n            if (hash) {\n                elm.setAttribute('href', '#' + hash);\n                elm.setAttribute('onclick', '');\n                elm.onclick = (ev) => {\n                    ev.preventDefault();\n                    const destination = document.getElementById(hash);\n                    if (destination) {\n                        const url = new URL(window.location.href);\n                        url.hash = hash;\n                        history.replaceState('', '', url.toString());\n                        destination.scrollIntoView();\n                    }\n                };\n                return;\n            }\n            const routes = yield this.routes;\n            const href = elm.getAttribute('href');\n            const lnk = basePathOnly(href.toLowerCase());\n            const route = routes.find((r) => basePathOnly(r.route.toLowerCase()) === lnk);\n            /** only upgrade routes known by scully. */\n            if (lnk && route && !lnk.startsWith('#')) {\n                elm.onclick = (ev) => __awaiter(this, void 0, void 0, function* () {\n                    const splitRoute = route.route.split(`/`);\n                    const curSplit = location.pathname.split('/');\n                    // loose last \"part\" of route\n                    curSplit.pop();\n                    ev.preventDefault();\n                    const routed = yield this.router.navigate(splitRoute).catch((e) => {\n                        console.error('routing error', e);\n                        return false;\n                    });\n                    if (!routed) {\n                        return;\n                    }\n                    /** check for the same route with different \"data\", and NOT a 1 level higher (length), and is not a fragment of th same page */\n                    if (curSplit.every((part, i) => splitRoute[i] === part) && splitRoute.length !== curSplit.length + 1) {\n                        setTimeout(() => this.replaceContent(), 10); // a small delay, so we are sure the angular parts in the page are settled enough\n                    }\n                });\n            }\n        });\n    }\n    replaceContent() {\n        /**\n         * as Angular doesn't destroy the component if we stay on the same page,\n         * we have to manually delete old content. Also we need to kick of loading\n         * the new content. handlePage() takes care of that.\n         */\n        /** delete the content, as it is now out of date! */\n        window.scullyContent = undefined;\n        const parent = this.elm.parentElement;\n        let cur = findComments(parent, 'scullyContent-begin')[0];\n        while (cur && cur !== this.elm) {\n            const next = cur.nextSibling;\n            parent.removeChild(cur);\n            cur = next;\n        }\n        this.handlePage();\n    }\n    getCSSId(elm) {\n        return elm.getAttributeNames().find((a) => a.startsWith('_ngcontent')) || '';\n    }\n    ngOnDestroy() {\n        this.routeSub.unsubscribe();\n        /** reset the lastused */\n        lastHandled = '//';\n    }\n}\n/** @nocollapse */ ScullyContentComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.6\", ngImport: i0, type: ScullyContentComponent, deps: [{ token: i0.ElementRef }, { token: ScullyRoutesService }, { token: i1.Router }, { token: i3.Location }, { token: i2.HttpClient }, { token: DOCUMENT }, { token: SCULLY_LIB_CONFIG }], target: i0.ɵɵFactoryTarget.Component });\n/** @nocollapse */ ScullyContentComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"12.0.0\", version: \"12.2.6\", type: ScullyContentComponent, selector: \"scully-content\", ngImport: i0, template: '<ng-content></ng-content>', isInline: true, styles: [\"\\n      :host {\\n        display: none;\\n      }\\n      scully-content {\\n        display: none;\\n      }\\n    \"], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None, preserveWhitespaces: true });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.6\", ngImport: i0, type: ScullyContentComponent, decorators: [{\n            type: Component,\n            args: [{\n                    // tslint:disable-next-line: component-selector\n                    selector: 'scully-content',\n                    template: '<ng-content></ng-content>',\n                    styles: [\n                        `\n      :host {\n        display: none;\n      }\n      scully-content {\n        display: none;\n      }\n    `,\n                    ],\n                    changeDetection: ChangeDetectionStrategy.OnPush,\n                    encapsulation: ViewEncapsulation.None,\n                    preserveWhitespaces: true,\n                }]\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: ScullyRoutesService }, { type: i1.Router }, { type: i3.Location }, { type: i2.HttpClient }, { type: Document, decorators: [{\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [SCULLY_LIB_CONFIG]\n                }] }]; } });\n\nclass ScullyContentModule {\n}\n/** @nocollapse */ ScullyContentModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.6\", ngImport: i0, type: ScullyContentModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n/** @nocollapse */ ScullyContentModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"12.2.6\", ngImport: i0, type: ScullyContentModule, declarations: [ScullyContentComponent], exports: [ScullyContentComponent] });\n/** @nocollapse */ ScullyContentModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"12.2.6\", ngImport: i0, type: ScullyContentModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.6\", ngImport: i0, type: ScullyContentModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: [ScullyContentComponent],\n                    exports: [ScullyContentComponent]\n                }]\n        }] });\n\nclass ScullyLibModule {\n    constructor(idle) {\n        this.idle = idle;\n    }\n    /**\n     * We use a little trick to get a working idle-service.\n     * First, we separate out the component in a separate module to prevent a circulair injection\n     * second we create a constuctor that activates the IdleMonitorService. as that is provided for 'root'\n     * there will be only 1 instance in our app.\n     */\n    static forRoot(config = ScullyDefaultSettings) {\n        config = Object.assign({}, ScullyDefaultSettings, config);\n        return {\n            ngModule: ScullyLibModule,\n            providers: [{ provide: SCULLY_LIB_CONFIG, useValue: config }],\n        };\n    }\n}\n/** @nocollapse */ ScullyLibModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.6\", ngImport: i0, type: ScullyLibModule, deps: [{ token: IdleMonitorService }], target: i0.ɵɵFactoryTarget.NgModule });\n/** @nocollapse */ ScullyLibModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"12.2.6\", ngImport: i0, type: ScullyLibModule, imports: [ScullyContentModule, HttpClientModule], exports: [ScullyContentModule] });\n/** @nocollapse */ ScullyLibModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"12.2.6\", ngImport: i0, type: ScullyLibModule, imports: [[ScullyContentModule, HttpClientModule], ScullyContentModule] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.6\", ngImport: i0, type: ScullyLibModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [ScullyContentModule, HttpClientModule],\n                    exports: [ScullyContentModule],\n                }]\n        }], ctorParameters: function () { return [{ type: IdleMonitorService }]; } });\n\n/*\n * Public API Surface of ng-lib\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { IdleMonitorService, ScullyContentComponent, ScullyContentModule, ScullyLibModule, ScullyRoutesService, TransferStateService, dropEndingSlash, isScullyGenerated, isScullyRunning };\n"]},"metadata":{},"sourceType":"module"}